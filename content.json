[{"title":"λ","date":"2019-11-01T15:28:00.000Z","path":"2019/11/01/2019/λ/","text":"关于λ经常会听到λ演算和λ表达式这两名词，其实分别对应的是理论和应用两个维度。它们的关系可以类比于质能方程和原子弹。 λ演算数学家阿隆佐-邱奇在20世纪30年代提出λ演算，作为数学基础研究的一部分。那个年代，数学界有个领袖，叫希尔伯特（一人之力将葛根廷大学建设为当时数的世界中心）。他提出将数学定理机械化，这样机器就可以通过形式语言推理出大量新定理（AI的味道？）。比他小几岁的图灵和邱奇都受到他这一思潮影响，并从不同的角度解决了这同一个问题。理论上，图灵机和λ演算，都可以模拟出我们今天所有的程序。 λ演算是一种形式系统(formal system)，什么是形式系统呢？大家知道，数学语言是是可以脱离现实而存在的——大家把数学想成了一种符号游戏，脱离生活常识，从公理开始，进行大量的推导和证明——最终产生一个系统，里面有公理、定理、推论、猜想…上述这种自成体系，有公理又有推理证明方法的体系，称为形式系统。而形式系统需要语言去描绘，这种语言就是形式语言(formal language)。邱奇希望用λ演算来表达有关数学的一切，比如用一系列函数来表达自然数，符号，定理等。 本质上图灵机和λ演算是做同一件事情，也是可以互相转换的。 Lambda表达式区别于λ演算中的λ表达式，编程中提到的Lambda表达式，一般就指一个匿名函数。为什么要用匿名函数，对于一个只用一次的函数，匿名使用当然更简洁方便。eg，给view一个点击事件： 12345678910111213// java 8以前view.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Log.d(\"click\",\"-----\"); &#125; &#125;);// java 8用上Lambda的匿名函数view.setOnClickListener(v -&gt; Log.d(\"click\",\"-----\"));// kotlin 版本view.setOnClickListener &#123; Log.d(\"click\", \"-----\") &#125; 那种写法更好一目了然，对吧。 所以在编程中使用Lambda表达式，可以让代码更符合直觉，写法清晰简练自然也带来更好的维护性。 好的维护性程序员不挠头，也可以推导出Lambda表达式具有程序员发际线友好特性。 λ与编程语言图灵机奠定了计算机基础，那能和它等价转化的λ演算呢？实际上λ演算在数学、哲学[2]、语言学[3][4]和计算机科学[5]中都有许多应用。它在编程语言理论中占有重要地位，函数式编程实现了λ演算支持。λ演算在范畴论中也是一个研究热点。 大部分编程语言都或多或少受λ演算所启发和影响，尤其是函数式友好语言（Lisp，ML，Haskell，Scala，C++，Java8 Lambda）。 Java8 实现Lambda的方式是通过invokedynamic指令，运行时调用LambdaMetafactory.metafactory动态的生成内部类，在内部类里调用原class的静态方法快来实现的。 应用在Java中能被Lambda改写的前提必须是一个函数接口（指内部只有一个抽象方法的接口）。 1234@FunctionalInterfacepublic interface ConsumerInterface&lt;T&gt;&#123; void accept(T t);&#125; 上面代码中的@FunctionalInterface不是必须而是可选的，但加上该标注编译器会帮你检查接口是否符合函数接口规范。就像加入@Override标注会检查是否重载了函数一样。 123456789101112131415161718192021222324252627//1，点击事件view.setOnClickListener(v -&gt; Log.d(\"click\",\"-----Hello\"));//2，线程方法Runnable run = () -&gt; Log.d(\"----Hello World\");//3，Collection (list)操作ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(\"hello\", \"world\"));list.forEach(it -&gt; Log.d(\"tag\", \"---\" + it));list.removeIf(it -&gt; it.startsWith(\"h\"));list.sort((o1, o2) -&gt; o1.length() - o2.length());//kotlinval list = listOf(\"hello\", \"world\")list.forEach &#123; print(it) &#125;list.filterNot &#123; it.startsWith(\"h\") &#125;list.sortedWith(Comparator &#123; o1, o2 -&gt; o1.length - o2.length &#125;) //4， Collection (map)操作Map&lt;String, String&gt; map = new HashMap&lt;&gt;();map.forEach((k, v) -&gt; Log.d(\"tag\", \"---\" + k + v));map.replaceAll((k, v) -&gt; v.toUpperCase());map.merge(\"key\", \"value\", (v1, v2) -&gt; v1 + v2);//kotlinval map = HashMap&lt;String, String&gt;()map.forEach &#123; (t, u) -&gt; print(\"----$t $u\") &#125;map.replaceAll &#123; t, u -&gt; u.toUpperCase() &#125;map.filter &#123; (t, u) -&gt; t.startsWith(\"h\") &#125; ###参考 https://zh.wikipedia.org/wiki/%CE%9B%E6%BC%94%E7%AE%97 https://zhuanlan.zhihu.com/p/30510749"},{"title":"ClipToPadding & ClipChildren","date":"2019-10-19T12:18:00.000Z","path":"2019/10/19/2019/ClipToPadding & ClipChildren/","text":"clipToPadding和clipChidren可以用来改变子视图的样式和行为 clipToPadding字面意思是根据padding来裁剪视图，如padding_top = 20dp，那么子视图从上边距20dp开始绘制。既然是padding相关，所以一般用在viewGroup里，尤其是可以滚动的recyclerView，scrollView等控制上下边距。 1，clipToPadding=”true” 123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;ScrollView xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"400dp\" android:paddingTop=\"16dp\" android:clipToPadding=\"true\" android:background=\"@android:color/holo_blue_bright\" android:orientation=\"vertical\"&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\"&gt; &lt;Button android:layout_width=\"match_parent\" android:layout_height=\"300dp\" android:text=\"button1\"/&gt; &lt;Button android:layout_width=\"match_parent\" android:layout_height=\"300dp\" android:layout_marginTop=\"16dp\" android:text=\"button2\"/&gt; &lt;/LinearLayout&gt;&lt;/ScrollView&gt; 2，clipToPadding=”false” 123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;ScrollView xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"400dp\" android:paddingTop=\"16dp\" android:clipToPadding=\"false\" android:background=\"@android:color/holo_blue_bright\" android:orientation=\"vertical\"&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\"&gt; &lt;Button android:layout_width=\"match_parent\" android:layout_height=\"300dp\" android:text=\"button1\"/&gt; &lt;Button android:layout_width=\"match_parent\" android:layout_height=\"300dp\" android:layout_marginTop=\"16dp\" android:text=\"button2\"/&gt; &lt;/LinearLayout&gt;&lt;/ScrollView&gt; clipChildren是否裁剪子视图，默认是true，一般情况子视图都在父视图里展示。也有些特别情况某个视图需要突出来，比如有些floatButton需要突出半边，这时需要设置为false。一般在root view里设置。 1，clipChildren=”true” 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;ScrollView xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"400dp\" android:background=\"@android:color/holo_blue_bright\" android:orientation=\"vertical\" android:clipChildren=\"true\" android:paddingTop=\"16dp\"&gt; &lt;LinearLayout android:layout_width=\"200dp\" android:background=\"@android:color/white\" android:layout_height=\"100dp\" android:orientation=\"vertical\"&gt; &lt;Button android:layout_width=\"600dp\" android:layout_height=\"300dp\" android:text=\"button1\"/&gt; &lt;/LinearLayout&gt;&lt;/ScrollView&gt; 2，clipChildren=”false” 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;ScrollView xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"400dp\" android:background=\"@android:color/holo_blue_bright\" android:orientation=\"vertical\" android:clipChildren=\"false\" android:paddingTop=\"16dp\"&gt; &lt;LinearLayout android:layout_width=\"200dp\" android:background=\"@android:color/white\" android:layout_height=\"100dp\" android:orientation=\"vertical\"&gt; &lt;Button android:layout_width=\"600dp\" android:layout_height=\"300dp\" android:text=\"button1\"/&gt; &lt;/LinearLayout&gt;&lt;/ScrollView&gt; 原理上面两个属性都在viewGroup，所以直接看源码，可以找到一个mGroupFlags属性，有clipToPadding的赋值，采用的位标记，在事件分发方法dispatchTouchEvent有相应逻辑来判断事件是否响应，在dispatchDraw里判断是否需要绘制。 参考https://stackoverflow.com/questions/40953049/android-what-does-the-cliptopadding-attribute-do/40955714#40955714"},{"title":"HashMap","date":"2019-09-16T04:41:00.000Z","path":"2019/09/16/2019/HashMap/","text":"HashMap在Java里是很常用的一种数据结构，今天来白话一下 定义HashMap 在Java中用来存放Key-Value，作用类比Python的dictionary和Javascript的object。它的特点就是块，查询和插入的复杂度都是O（1），内存开销也是稳定的。 用法123Map map = new HashMap&lt;String, Activity&gt;(4);map.put(\"a\", AnimationActivity());map.get(\"a\"); 哈希和散列这俩个词是啥关系？emmmr，好比西红柿和番茄吧。一个是hash的音译一个是意译。所以听到什么哈希表和散列表不要奇怪，它们都在说同一个东西，哈希表叫法的最早来源可能是hashmap里的 Node&lt;K,V&gt;[] table.没错哈希表是一个数组，这是它curd操作复杂度O（1）的基石。 取模&amp;取余正数没有差别，区别在于负数向0取余，远离0取模 12347 mod 4 = 3（商 = 1 或 2，1&lt;2，取商=1）-7 mod 4 = 1（商 = -1 或 -2，-2&lt;-1，取商=-2）7 mod -4 = -1（商 = -1或-2，-2&lt;-1，取商=-2）-7 mod -4 = -3（商 = 1或2，1&lt;2，取商=1） 哈希值Java所有类祖宗都是Object，Object里提供了hashCode（）的默认实现。hashCode又是通过identityHashCode获取，identityHashCode是一个native方法，根据对象在内存中的地址运算得到。我们可以通过重写hashCode来覆盖这个值，但System.identityHashCode()返回的值是不变的（内存没变的话）。 12345678910111213141516String a = \"test\"String b = \"test\"// 打印这两个值的hashcode发现是一样的，这是符合我们的实际使用场景的，可见String的hashCode是有重写过。// 查看源码，可以看到String的hashCode是基于内容运算得到。public int hashCode() &#123; int h = hash; final int len = length(); if (h == 0 &amp;&amp; len &gt; 0) &#123; for (int i = 0; i &lt; len; i++) &#123; h = 31 * h + charAt(i); &#125; hash = h; &#125; return h; &#125; 重写hashCode为什么要重写hashCode？是因为我们希望对象的hashCode可以持久，对象不变hashCode也不变。但是Object基于内存得到的hashCode是会跟着内存地址由于各种原因变化的（比如GC）。如果我们需要重写hashCode，我们需要考虑三点：稳定性（hash值和对象属性相关）；要块；要离散，Effective java有以下建议： 域类型 计算 boolean c=(f?0:1) byte,char,short,int c=(int)f long c=(int)(f^(f&gt;&gt;&gt;32)) float c=Float.floatToIntBits(f) double long l = Double.doubleToLongBits(f)c=(int)(l^(l&gt;&gt;&gt;32)) 数组 对每个元素分别计算 Result = 31 * result + c 实现HashMap有以上这些储备，我们自己也可以实现一个HashMap了 1231，实例化一个数组Object [] table2，写一个getTableIndex方法，用Object.hashCode() 对数组长度取模3，拿到index就可以对table数组进行curd操作，时间复杂度也是O(1) 实现简单，但问题很明显，实际上这样实现的HashMap效率会非常低，原因是： 1231，没考虑resize，而实际情况中HashMap需要经常动态resize，这样才能兼顾时间和空间的效率2，即使不考虑空间复杂度，初始化一个很大的数组，不同的Object的hashCode还是有可能一样，这时就崩了3，没支持范型，会很难用 所以JDK里的HashMap是采用数组加链表来实现（java 8后链表会和红黑树动态变换）。 HashMap的HashHashMap的重点在Hash，所以Hash算法的设计就是从速度，效率，质量综合考虑来设计的 123456789// 1，取hashCode// 2，高位参与运算，这主要是让hash更离散，提高hash质量static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125; // 3，用位运算代替取模 tab[i = (n - 1) &amp; hash] 能用位运算代替取模的前提是n必须是2的整数次方，源码对table数组的size也确实做了限制，而且对reszie也有帮助，新位置 = 原位置 + 原size 12345678910// 位运算比一般的取模运算效率更高是因为取模需要做除法，触发器运算要多一个cpu时钟 static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; &#125; HashMap 线程安全HashMap不是线程安全的，在resize时可能会出现环形链表，这时就死循环了。多线程下一般推荐使用ConcurrentHashMap。 初始变量123456static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;static final float DEFAULT_LOAD_FACTOR = 0.75f;static final int TREEIFY_THRESHOLD = 8;static final int UNTREEIFY_THRESHOLD = 6;static final int MIN_TREEIFY_CAPACITY = 64;"},{"title":"ImageView ScaleType and Transition","date":"2019-09-08T15:31:00.000Z","path":"2019/09/08/2019/ImageView/","text":"ImageView 是很常用的控件，记录下ScaleType和Transition animation ImageView ScaleType 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:id=&quot;@+id/faceLayout&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;Button android:id=&quot;@+id/button2&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Button&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot;/&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 1234// 这三个属性尽量搭配一起使用，除了center和matrix，其他效果都一致，显示正常不拉伸的图片。android:layout_width=&quot;0dp&quot;android:layout_height=&quot;wrap_content&quot;android:adjustViewBounds=&quot;true&quot; ImageView Transitionhttps://medium.com/@andkulikov/animate-all-the-things-transitions-in-android-914af5477d50 1，改变图片属性 12345678910val animator = ValueAnimator.ofFloat(0f, 1f) animator.duration = Constants.ThrottleDuration.NORMAL animator.addUpdateListener &#123; animation -&gt; val animatorValue = animation.animatedValue as Float videoView.translationX = 50 * animatorValue videoView.translationY = 100 * animatorValue videoView.scaleX = 1f - 0.8f * animatorValue videoView.scaleY = 1f - 0.5f * animatorValue &#125; animator.start() 2，利用transition改变layoutParams 1234567891011121314151617181920212223242526272829val marginHorizontal = UtilResource.getDimensionPixelSize(R.dimen.margin_horizontal) val container = mRoot.transitionLayout val transitionSet = TransitionSet() .addTransition(ChangeBounds()) .addTransition(ChangeImageTransform()).addListener(object : TransitionListenerAdapter()&#123; override fun onTransitionStart(transition: Transition) &#123; super.onTransitionStart(transition) UtilLog.d(sTAG, &quot;------full start &quot;) &#125; override fun onTransitionEnd(transition: Transition) &#123; super.onTransitionEnd(transition) UtilLog.d(sTAG, &quot;------full end&quot;) &#125; &#125;) TransitionManager.beginDelayedTransition(container, transitionSet) val params = videoView.layoutParams as ViewGroup.MarginLayoutParams UtilLog.d(sTAG, &quot;------full $isScale $params&quot;) params.height = if (isScale) ViewGroup.LayoutParams.MATCH_PARENT else ViewGroup.LayoutParams.WRAP_CONTENT if (isScale) &#123; params.setMargins(0, 0, 0, 0) &#125; else &#123; params.setMargins(marginHorizontal, marginHorizontal, marginHorizontal, 0) &#125; videoView.layoutParams = params (videoView as ImageView).scaleType = if (isScale) ImageView.ScaleType.CENTER_CROP else ImageView.ScaleType.FIT_START"},{"title":"ConstraintLayout IN Jetpack","date":"2019-09-01T16:30:00.000Z","path":"2019/09/02/2019/ConstraintLayout IN Jetpack/","text":"曾经Android布局就一把梭，RelativeLayout+LinearLayout，直到用ConstraintLayout写了几个页面后发现是真的香，现在任何布局第一选择都是它。 ConstraintLayout是什么？ 它属于Android JetPack，当前版本implementation &#39;com.android.support.constraint:constraint-layout:1.1.3&#39; 作用是可以减少视图布局层级，很复杂的页面一般也就是两个层级能搞定 响应式布局代码更健壮，轻松适配不同分辨率 更好的可视化操作，通过Android Studio的Layout Editor就可以实时拖动编辑并预览布局效果 基本用法问：布局基本三要素是什么？ 答：位置，对齐，大小。 1，位置，View放在哪里ConstraintLayout的做法和RelativeLayout是差不多的，实际使用起来Constraint Layout的字段语义更符合直觉。 Relative Layout Constraint Layout 垂直居中 android:layout_centerVertical=”true” app:layout_constraintBottom_toBottomOf=”parent” app:layout_constraintTop_toTopOf=”parent” 居下 android:layout_below=”@id/view” app:layout_constraintTop_toBottomOf=”@id/view” 居右 android:layout_toEndOf=”@id/view” app:layout_constraintStart_toEndOf=”@id/view” 2，对齐，整整齐齐还是错落有致，当然是都要严格来讲Relative Layout里面的子View之间是无法相互对齐的。有两种方式可以间接做到：是基于父视图对齐和嵌套一个ViewGroup比如LinearLayout来对齐。这也就是为什么即使用Relative Layout做的布局也很可能层数过多，出现overDraw。而ConstraintLayout就很优雅了，要领就是Start_toStartOf，End_toEndOf，Top_toTopOf，Bottom_toBottomOf两两结对出现就行。 123456789101112131415161718192021222324252627// 上图示例，基于View水平对齐&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;Button android:id=\"@+id/btn1\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"Button test\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\"/&gt; &lt;Button android:id=\"@+id/btn2\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"btn2\" app:layout_constraintEnd_toEndOf=\"@id/btn1\" app:layout_constraintStart_toStartOf=\"@id/btn1\" app:layout_constraintTop_toBottomOf=\"@id/btn1\"/&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout 1234567891011121314151617181920212223242526272829// 基于View垂直对齐&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;Button android:id=\"@+id/btn1\" android:layout_width=\"wrap_content\" android:layout_marginTop=\"50dp\" android:layout_height=\"wrap_content\" android:text=\"Button test\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\"/&gt; &lt;Button android:id=\"@+id/btn2\" android:layout_width=\"wrap_content\" android:layout_height=\"40dp\" android:layout_marginStart=\"10dp\" android:text=\"btn2\" app:layout_constraintBottom_toBottomOf=\"@id/btn1\" app:layout_constraintStart_toEndOf=\"@id/btn1\" app:layout_constraintTop_toTopOf=\"@id/btn1\"/&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 3，大小控制基本用法和普通ViewGroup一致，无非就是wrap_content,0dp,margin,padding这些来控制View大小。 熟练掌握这些，已经可以愉快的和ConstraintLayout玩起来了，慢慢的也能体会到它的精妙之处，当然Constraintlayout还有些进阶用法。 进阶用法1，Guideline（可以影响View的位置，大小，对齐方式） 1234567891011121314// 不可见的辅助布局线，水平和垂直，数值和百分比都支持，常用来切割页面，辅助布局&lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/guideline2\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\" app:layout_constraintGuide_percent=\"0.27980536\"/&gt;&lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/guideline3\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\" app:layout_constraintGuide_begin=\"171dp\"/&gt; 2，Barrier（主要影响View的位置） 123456789101112131415161718192021222324252627282930313233343536// 同样是不可见的辅助布局线，区别于Guideline，它自己不定义位置，而且根据它绑定的View动态确定位置// 右边的C始终距离左边的A，B有一个固定的距离margin// barrierDirection 指定 barrier相对于绑定View的方位// constraint_referenced_ids 指定绑定子View的id，用逗号分隔 &lt;Button android:id=\"@+id/btn1\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"50dp\" android:text=\"Button test\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\"/&gt; &lt;Button android:id=\"@+id/btn2\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"btn2\" app:layout_constraintStart_toStartOf=\"@id/btn1\" app:layout_constraintTop_toBottomOf=\"@id/btn1\"/&gt; &lt;Button android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginStart=\"20dp\" android:text=\"btn3\" app:layout_constraintStart_toEndOf=\"@id/barrier\" app:layout_constraintTop_toTopOf=\"@id/btn1\"/&gt; &lt;androidx.constraintlayout.widget.Barrier android:id=\"@+id/barrier\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" app:barrierDirection=\"right\" app:constraint_referenced_ids=\"btn1,btn2\" /&gt; 3，Bias（偏移，影响位置） 12345678910111213// Bias的起作用的前提是：有成对的水平约束（Start_toStartOf和End_toEndOf）或竖直约束（Top_toTopOf和// Bottom_toBottomOf），并且view没有设置wrap_content和fixed（也就是说还有剩余的位置可供偏移，默认是// 居中）&lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginStart=&quot;20dp&quot; android:layout_marginEnd=&quot;8dp&quot; android:text=&quot;btn3&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintHorizontal_bias=&quot;0.4&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot;/&gt; 4，Chain（链条，影响位置和对齐）在ConstraintLayout中生成一个链条，最少只需要两个View相互指定Constraint。作用类似于Flex 布局中的轴axis。 1234567891011121314151617&lt;Button android:id=\"@+id/button2\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"Button\" app:layout_constraintEnd_toStartOf=\"@+id/button3\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\"/&gt; &lt;Button android:id=\"@+id/button3\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"Button\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toEndOf=\"@+id/button2\" app:layout_constraintTop_toTopOf=\"parent\"/&gt; Chain既然像Flex，那确实是可以像Flex类似的用的： 123456789101112131415161718192021222324252627282930313233// layout_constraintHorizontal_chainStyle 默认是spread，还有Packed和Spread Inside可以选，// layout_constraintHorizontal_weight 和Learnelayout的weight一样用法，需要0dp（match_constraint） &lt;Button android:id=&quot;@+id/button2&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Button&quot; app:layout_constraintHorizontal_chainStyle=&quot;spread&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/button3&quot; app:layout_constraintHorizontal_weight=&quot;1&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot;/&gt; &lt;Button android:id=&quot;@+id/button3&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Button&quot; app:layout_constraintHorizontal_weight=&quot;2&quot; app:layout_constraintEnd_toStartOf=&quot;@id/button4&quot; app:layout_constraintStart_toEndOf=&quot;@+id/button2&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot;/&gt; &lt;Button android:id=&quot;@+id/button4&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Button&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toEndOf=&quot;@id/button3&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; 5，Ratio（比例，影响大小）123456// 根据宽高比例自适应View大小，至少一个被设为0dp（match_constraint）,下面的代码你将收获一个全屏的按钮&lt;Button android:layout_width=&quot;0dp&quot; android:layout_height=&quot;0dp&quot; app:layout_constraintDimensionRatio=&quot;H,16:9&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot;/&gt; 6，Visibility behavior（影响位置） 123// 如上图，A的margin_start 16,B的margin_start 20,那A变gone了，B希望start margin加大一点，只需要// 加一句app:layout_goneMarginStart=\"@dimen/margin_26\" 7，Circular positioning（影响位置） 123456// 比较少能用上，原理就是A根据原点半径和角度来定位B&lt;Button android:id=\"@+id/buttonA\" ... /&gt; &lt;Button android:id=\"@+id/buttonB\" ... app:layout_constraintCircle=\"@+id/buttonA\" app:layout_constraintCircleRadius=\"100dp\" app:layout_constraintCircleAngle=\"45\" /&gt; 8，Keyframe animations（影响大小，位置，但不会改变颜色）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// MotionLayout才是完全体，不过这个也很简单好用了// MainActivity.ktprivate lateinit var constraintLayout: ConstraintLayoutfun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.keyframe_one) constraintLayout = findViewById(R.id.constraint_layout) // member variable&#125;fun animateToKeyframeTwo() &#123; val constraintSet = ConstraintSet() constraintSet.load(context, R.layout.fragment_key_2) TransitionManager.beginDelayedTransition(constraintLayout) constraintSet.applyTo(constraintLayout)&#125;// layout/keyframe1.xml&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:id=\"@+id/faceLayout\" android:layout_height=\"match_parent\"&gt; &lt;Button android:id=\"@+id/button2\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:text=\"Button\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\"/&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;// layout/keyframe2.xml// Keyframe 2 contains another ConstraintLayout with the final positions&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:id=\"@+id/keyLayout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;Button android:id=\"@+id/button2\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:text=\"Button\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"parent\"/&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 总结：用过就回不去了，没有Constraintlayout甚至不会布局。 参考https://developer.android.com/reference/android/support/constraint/ConstraintLayout#VirtualHelpers https://developer.android.com/training/constraint-layout#constrain-to-a-barrier"},{"title":"Hexo+Github Pages CDN & HTTPS","date":"2019-08-18T13:03:00.000Z","path":"2019/08/18/2019/Hexo+Github Pages CDN & HTTPS /","text":"在Hexo和Github Pages的加持下，现在我们可以只专注在写Blog上，而不用额外的精力管网站发布和运营。一起看起来很美好，然而，一段时间过去了，会发现文章没写几篇，网站倒是卡成姥爷，浏览器还一直显示不安全。需要一些手段来解决下。 名词概念CDN全称是Content Delivery Network，最小CDN网络可以由一个DNS服务器和几台缓存服务器组成，不同地区的访问请求，CDN会智能安排最近的服务器响应，而且还有Cache来加速。所以CDN的效果取决于DNS服务器调度算法和缓存服务器的数量以及质量，CDN的作用域是域名而不是服务器。 DNSDomain Name System是互联网的一项服务，它作为域名和IP地址互相映射的一个分布式系统，让用户更方便访问互联网。互联网通信是只认IP地址的，但一串数字人是记不住的，人容易记住的是apple.com这样的单词，这个叫域名，让电脑知道apple.com就是要访问122.224.45.229，就通过DNS域名解析系统。DNS系统中，常见的资源记录类型有： 主机记录（A记录）：RFC 1035定义，A记录是用于名称解析的重要记录，它将特定的主机名映射到对应主机的IP地址上。 别名记录（CNAME记录）: RFC 1035定义，CNAME记录用于将某个别名指向到某个A记录上，这样就不需要再为某个新名字另外创建一条新的A记录。 IPv6主机记录（AAAA记录）: RFC 3596定义，与A记录对应，用于将特定的主机名映射到一个主机的IPv6地址。 服务位置记录（SRV记录）: RFC 2782定义，用于定义提供特定服务的服务器的位置，如主机（hostname），端口（port number）等 CNAME想想为啥要用CNAME。用户输入的是xxx.com，打开的是xxx.github.io网页，这中间的魔法就是通过CNAME实现的，我们在DNS域名解析服务里设定了解析规则，*和www开头的记录都重定向到hxx.github.io域名。这里用CNAME的好处是github换IP操作对我们透明，从而不需要手动改配置。 实施有以上储备后，就可以开搞了。诉求是CDN和HTTPS加密，因为域名是万网（阿里云）买的，所以先看了一眼阿里云SSL证书价格，最便宜1256一年，emmm，这不科学，Blog我们当然是要免费的。查阅一番，Cloudflare评价不错。 打开Cloudflare的官网，竟然对中文有支持，赞👍 注册Cloudflare这步比较简单，按提示注册就行 配置Site注册成功就会让你Add Site， 输入你的域名xxx.com，选套餐，当然是Free 更改域名商 意思是去你的域名服务商更改nameservers，熟练登入阿里云，选择域名点击最右边域名管理 点击修改DNS，修改成james开头的地址就行，改完点一下同步，一般5分钟内生效。 验证是否生效左上角Cloudflare回主页 或者命令行：用dig www.hxx.com 搜索一下ip104.31.94.161，确认是Cloudflare的，现在你打开Blog的页面速度应该有数量级的提升！ 对比效果Before，2分钟开一个网页，实际上是对人耐心的一种考验 After，可以说是秒开了，而且有无翻墙，效果一致，193个数据中心不是白吹的，美滋滋。 地址栏显示不安全 我们的静态页面当然是绿色无害的，但由于没开启HTTPS被Chrome标记为不安全。怎么部署HTTPS有好多方案，这里不多讲，Blog我们就要5分钟能上手的😁 还是Cloudflare，选择Crypto。 解释一下右边的类型 Flexible SSL：使用Cloudflare提供的免费证书，用户到Cloudflare采用加密连接，从Cloudflare到主机（github.io）不走加密连接。 Full SSL：需要一个SSL证书，但是Cloudflare不会校验证书的来源 Full SSL（Strict）：需要SSL证书，并且会校验证书的来源是不是第三方合法机构签署颁发 1234567891011Origin Certificates，我们让Cloudflare帮生成一个Always Use HTTPS，打开HSTS可以打开，按照它推荐的设置Opportunistic Encryption，打开Onion Routing，打开Automatic HTTPS Rewrites，打开 这个配置改动后，Cloudflare表示最长需要24小时生效，实际上半个小时左右就ok，等待时间可以玩玩Cloudflare的其他功能，毕竟不花钱，推荐配置下Speed 半个小时后强制刷新一下页面，确认效果 参考https://www.cloudflare.com https://cloud.tencent.com/developer/article/1354904"},{"title":"Android Google Play 上车指南","date":"2019-08-11T15:07:00.000Z","path":"2019/08/11/2019/google play 上车指南/","text":"如果你的Android 应用不只在中国运营，还想国际化，比如服务一下美帝人民，那上Google Play是必须的。这里记录下 必要的准备 一个Gmail帐号，Google Play Console 登录只接受Google帐号 一张支持境外支付的信用卡（visa/mastercard），注册需要支付$25 文档理解-Android APP bundle 文档理解-APP Signing 软件著作权（不需要） 帐号注册这个流程需要自带梯子，注册地址，按提示走一般没啥幺蛾子 App BundleAndroid生态过了10年，系统碎片化严重，应用越来越大。Google终于决定要有所改变了，在2018年中推出了Android App Bundle这个新的文件格式。期望来达到三个目的：1，动态分发，服务器根据用户机型动态下发对应资源的APK，减少应用包体积（落后iOS N年）；2，动态功能模块，比如支付，播放这种功能可以在使用时候动态加载；3，应用安全，集成App signing，保证APP安装和升级的合法性。使用也比较简单 需要Android Studio 3.2+，命令行可以使用bundletool 添加Dynamic Delivery支持 用AS打一个Android APP bundle文件，在AS工具栏选build，选build bundles，文件格式是.aab 测试aab bundle文件 上传到Google play签名 一个20M的测试apk，使用app bundle经过google play下发到用户手机只有6m左右，美滋滋。 App signing相对于apk，App Bundle的aab是一种新的上传文件格式，必须搭配App signing一起使用。Google Play来管理和保护你的应用签名密钥，并使用它来签名apk以进行动态分发。 怎么工作？应用密钥储存在Google的无差别基建服务中，并提供安全可靠行保证。使用密钥签名生成aab文件，aab上传Google Play会校验公共证书是不是来自于受信任的来源（同一个）。 Upload key？这个是可选的，就是多生成一个Java keystore，用来区别应用打包签名的keystore。它只用在上传aab文件时做合法性校验。如果App Signing选择了Google自动生成私钥，那这个upload key会是第一次上传文件时的签名keystore。 祖传的签名key能用？可以，在开启App signing服务时选择上次祖传的私有keystore，然后新建一个keystore用来作为Upload key。 各种key 相关概念 Term Description App signing Google Play使用这个key来签名分发给用户的apk，使用app sign服务时google会帮你创建一个，当然也可以上传一个已有的。一个应用只能被签名一次。 Upload key 用来保障aab上传文件的合法性和安全性，强烈推荐新建一个，不要和sign key用同一个。 Certificate (.der or .pem) 一个证书包含了公钥和谁拥有密钥的额外识别信息 Certificate fingerprint 证书的简短表示，一般有MD5，SHA-1，SHA-265 Java keystore (.jks or .keystore) 储存安全证书和私钥的文件 Play Encrypt Private Key (PEPK) tool 一种从Java密钥库导出私钥并加密它们以便传输到Google Play的工具。 参考https://developer.android.com/guide/app-bundle https://support.google.com/googleplay/android-developer/answer/9006925?hl=en https://support.google.com/googleplay/android-developer/answer/7384423 https://medium.com/googleplaydev/what-a-new-publishing-format-means-for-the-future-of-android-2e34981793a"},{"title":"WorkManager IN Jetpack","date":"2019-08-03T15:07:00.000Z","path":"2019/08/03/2019/WorkManager IN /","text":"WorkManager是Android Jetpack的架构组件（Architecture component）之一，官方对它的定义是用来管理Android后台作业。 简单上手1，添加依赖 123456789// 在app的build.gradle里添加//A： Kotlin + coroutinesimplementation 'androidx.work:work-runtime-ktx:2.1.0'//B： Java onlyimplementation 'androidx.work:work-runtime:2.1.0'//C： optional - RxJava2 supportimplementation 'androidx.work:work-rxjava2:2.1.0' 2，实现一个Worker 123456789101112131415161718192021222324252627282930// 相当于一个Taskclass CountNumWorker(appContext: Context, workerParams: WorkerParameters) : Worker(appContext, workerParams) &#123; private val count = inputData.getInt(COUNT, 0) private val name = inputData.getString(NAME) ?: \"bob\" override fun doWork(): Result &#123; var sum = 0 for (i in 0..count) &#123; sum += i sleep() Log.d(TAG, \"-----$name count $count || sum $sum\") &#125; return Result.success() &#125; private fun sleep() &#123; val time = Math.random() * 400 + 100 Log.d(CountNumWorker.TAG, \"----$time\") try &#123; Thread.sleep(time.toLong(), 0) &#125; catch (e: InterruptedException) &#123; Log.e(CountNumWorker.TAG, \"----$e\") &#125; &#125; companion object &#123; const val TAG = \"CountNumWorker\" const val COUNT = \"count\" const val NAME = \"name\" &#125;&#125; 3，创建一个WorkRequest 12// 定义怎么运行Worker，下面这个worker将只运行一次，对应的还有周期运行的PeriodicWorkRequestBuilderval workRequest = OneTimeWorkRequestBuilder&lt;CountNumWorker2&gt;().build() 4，执行Worker 12// 调用WorkManager单例开始workerWorkManager.getInstance().enqueue(workRequest) WorkerManager作为JetPack一员，官方强烈安利搭配LiveData and ViewModel一起食用。不过单独用也完全OK，而且上手是很简单的。执行后台任务我们已经有AsyncTask，ThreadPools，RxJava…那WorkManager需要足够理由来说服大家上车。 WorkManager是啥？WorkManager可以用来轻松安排非立即执行的异步任务，即使程序退出或者手机重启。 关键功能 支持API 14以上机型，在API 14-22使用BroadcastReceiver + AlarmManager，23+则是JobScheduler 给work添加触发条件，比如特定网络状态和或电池多少以上才执行 可以单次或周期的执行异步任务 监视和管理任务 按组按序执行任务 可以确保任务执行，即使app退出或手机重启，叼 电池友好，即使休眠模式也能工作 使用场景 发送logs或analytics给后端 周期性和后端同步app数据 什么时候用 敲黑板：是否需要立即执行的前提很重要，比如用户希望立即运行不被打断，那WorkManager就表示做不到了，这时需要用foreground service。其他情况下首选WorkManager，它具有更高的兼容性和更优雅的封装性。 进阶使用1，传递数据 123456789101112131415//IN： requestBuilder 往worker塞数据workRequestBuilder.setInputData(getCountData(&quot;bob&quot;,10))//IN： Data里面有个Map接收数据private fun getCountData(name: String, count: Int): Data &#123; val builder = Data.Builder() CountNumWorker.TAG builder.putInt(CountNumWorker.COUNT, count) builder.putString(CountNumWorker.NAME, name) return builder.build() &#125;//OUT：worker里面取数据private val count = inputData.getInt(COUNT, 0)private val name = inputData.getString(NAME) ?: &quot;bob&quot; Tips: Data 传递的数据只能是Boolean, Integer,Long, Float, Double, String和这些类型的数组，如果想要传递一些复杂对象，那么有下面几种方式： 实现复杂度 用法&amp;副作用 静态变量 简单 用完忘记置空，影响和内存泄漏差不多 单例赋值 简单 思考是否合适用单例 借助json 一般 对象转成bean，toString后用Data传，接收到在fromJson还原成bean 数据库 复杂 生产者插数据库，用Data传id，消费者用id查数据库 2，监听worker执行状态 12345678910// 实例化一个workRequestBuilderval workRequestBuilder = OneTimeWorkRequestBuilder&lt;CountNumWorker2&gt;()// 设置一下TAGworkRequestBuilder.addTag(&quot;bob&quot;)// 监听特定TAG的worker的执行状态workerManager.getWorkInfosByTagLiveData(&quot;bob&quot;).observe(this, Observer &#123; workInfo -&gt; if (workInfo != null &amp;&amp; workInfo.first().state == WorkInfo.State.SUCCEEDED) &#123; UtilToast.show(&quot;----success!&quot;) &#125; &#125;) Tips：worker可以有三种方式标示：name，id，tag。tag可以在workRequestBuilder上设置，表示一个组的worker，name和id都是在workRequestBuilder.build()后可以获取，表示单个worker，通过WorkContinuation可以设置。 3，串并联worker，S队形B队形随意排 123456789101112131415161718192021222324252627282930313233 * A * | * +----------+ * | | * Bob lucy * | | * +----------+ * | * B// A任务先执行，然后bob和lucy一起跑，跑完了再跑B workerval workRequestBuilder = OneTimeWorkRequestBuilder&lt;CountNumWorker2&gt;()val workRequestBuilder2 = OneTimeWorkRequestBuilder&lt;CountNumWorker2&gt;()val workRequestBuilderA = OneTimeWorkRequestBuilder&lt;CountNumWorker&gt;()val workRequestBuilderB = OneTimeWorkRequestBuilder&lt;CountNumWorker&gt;()workRequestBuilder.setInputData(getCountData(\"bob\",10))workRequestBuilder2.setInputData(getCountData(\"lucy\",15))workRequestBuilderA.setInputData(getCountData(\"A\", 15))workRequestBuilderB.setInputData(getCountData(\"B\", 15))val list = listOf(workRequestBuilder.build(), workRequestBuilder2.build())workerManager.beginWith(workRequestBuilderA.build()).then(list).then(workRequestBuilderB.build()).enqueue() * A C * | | * B D * | | * +-------+ * | * E // 左右两边任务同时跑起来，文体两开花安排上WorkContinuation left = workManager.beginWith(A).then(B);WorkContinuation right = workManager.beginWith(C).then(D);WorkContinuation final = WorkContinuation.combine(Arrays.asList(left, right)).then(E);final.enqueue(); 4，Cancelling and stopping work 123WorkManager.cancelWorkById(workRequest.id)workerManager.cancelAllWorkByTag(\"bob\")workerManager.cancelUniqueWork(\"lucy\") 5，周期任务 123456789101112// 充电时worker才工作val constraints = Constraints.Builder() .setRequiresCharging(true) .build()// 设置requestval saveRequest =PeriodicWorkRequestBuilder&lt;SaveImageToFileWorker&gt;(1, TimeUnit.HOURS) .setConstraints(constraints) .build()// 安排上WorkManager.getInstance() .enqueue(saveRequest) 6，WorkManager的线程模型 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 简单来说就是三种，本文最开头的添加依赖里标了A，B，C// 如果依赖B，那只能使用基础的Workerclass DownloadWorker(context: Context, params: WorkerParameters) : Worker(context, params) &#123; override fun doWork(): ListenableWorker.Result &#123; for (i in 0..99) &#123; try &#123; downloadSynchronously(\"https://www.google.com\") &#125; catch (e: IOException) &#123; return ListenableWorker.Result.failure() &#125; &#125; return ListenableWorker.Result.success() &#125;&#125;// Worker默认是会创建一个Executor，但也可以自定义WorkManager.initialize( context, Configuration.Builder() .setExecutor(Executors.newFixedThreadPool(8)) .build())// 如果依赖A（推荐），那可以使用Worker和CoroutineWorker，协程美滋滋class CoroutineDownloadWorker(context: Context, params: WorkerParameters) : CoroutineWorker(context, params) &#123; override val coroutineContext = Dispatchers.IO override suspend fun doWork(): Result = coroutineScope &#123; val jobs = (0 until 100).map &#123; async &#123; downloadSynchronously(\"https://www.google.com\") &#125; &#125; // awaitAll will throw an exception if a download fails, which CoroutineWorker will treat as a failure jobs.awaitAll() Result.success() &#125;&#125;// RxJava2重度患者，在A或B的基础上加个C，就可以多个RxWoker使用public class RxDownloadWorker extends RxWorker &#123; public RxDownloadWorker(Context context, WorkerParameters params) &#123; super(context, params); &#125; @Override public Single&lt;Result&gt; createWork() &#123; return Observable.range(0, 100) .flatMap &#123; download(\"https://www.google.com\") &#125; .toList() .map &#123; Result.success() &#125;; &#125;&#125; 参考https://developer.android.com/topic/libraries/architecture/workmanager https://codelabs.developers.google.com/codelabs/android-workmanager-kt/#0 https://medium.com/androiddevelopers/introducing-workmanager-2083bcfc4712"},{"title":"自定义验证码输入View","date":"2019-07-29T12:28:00.000Z","path":"2019/07/29/2019/自定义验证码输入View/","text":"我们现在要实现一个自定义输入框，显示用户接受到的验证码，大概是长这样 思路分析Q：需要有哪些功能？ A：框代表的是验证码长度，这个需要可配置；只接收数字并可以编辑删除；输入和未输入有状态区别 Q：可以怎么实现？ A：直觉上是直接继承EditView，重写onDraw方法 Q：为什么要继承EditView而不是TextView甚至是View？ A：如果继承View，那控件的逻辑能力也需要自己实现，比如输入法的弹出和隐藏，输入法内容的接收需要重写onCreateInputConnection等方法。EditView比TextView多的能力是设置Selection光标位置，文字默认可编辑可定义输入法类型。 综上：该自定义需求，系统控件的EditView功能上可以满足，只是需要自定义魔改下UI。 码上1，新建一个自定义View继承于EditView，并复写onDraw和onMeasure 123456789101112131415class CustomInputView2 : EditText &#123; constructor(context: Context?) : super(context) constructor(context: Context?, attrs: AttributeSet?) : super(context, attrs) constructor(context: Context?, attrs: AttributeSet?, defStyleAttr: Int) : super(context, attrs, defStyleAttr) // 控件需要知道自己的大小和边距padding，才能符合预期的绘制 override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec) &#125; // 绘制框框和数字 override fun onDraw(canvas: Canvas?) &#123; super.onDraw(canvas) &#125;&#125; 2，仔细看一下onMeasure 1234567891011121314151617181920212223242526override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec) val widthMode = MeasureSpec.getMode(widthMeasureSpec) var widthSize = MeasureSpec.getSize(widthMeasureSpec) val heightMode = MeasureSpec.getMode(heightMeasureSpec) var heightSize = MeasureSpec.getSize(heightMeasureSpec) val realWidth = itemWith.toInt() * itemNum val realHeight = itemWith.toInt() // 当控件类型指定为wrap_content时，它的mode是MeasureSpec.AT_MOST， // 具体大小需要自己计算出来，算的时候要加上对应padding when &#123; widthMode == MeasureSpec.AT_MOST &amp;&amp; heightMode == MeasureSpec.AT_MOST -&gt; &#123; widthSize = realWidth + paddingLeft + paddingRight heightSize = realHeight + paddingTop + paddingBottom &#125; widthMode == MeasureSpec.AT_MOST -&gt; &#123; widthSize = realWidth + paddingLeft + paddingRight &#125; heightMode == MeasureSpec.AT_MOST -&gt; &#123; heightSize = realHeight + paddingTop + paddingBottom &#125; &#125; //calculate itemGap with padding, 本控件设计占一行，那每个框之间的间隔是需要算出来并赋值的 itemGap = (widthSize - (paddingStart + paddingEnd) - realWidth) / (itemNum - 1) setMeasuredDimension(widthSize, heightSize) &#125; 3，把元素绘制上去，onDraw 画图三要素：画布（canvas），画笔（paint），画哪里（LRTB）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 1，绘制框，调用canvas API drawRoundRect(rectF, itemRadius, itemRadius, paint)// 2，需要rectF来确定画在哪里，比如第一个框：// val top = paddingTop.toFloat()// val bottom = height - paddingBottom.toFloat()// val left = paddingStart// val reght = itemWith + paddingStart// rectF.set(left, top, right, bottom)// 3，绘制剩下的框只需要left和right加对应的itemWith和itemGap// 4，绘制文字调用canvas API drawText(String text, float x, float y, Paint paint)// 5，文字居中：paint需要设置textAlign = Paint.Align.CENTER，这样可以保证x处于文字的中点，Y轴的中// 点由于文字渲染的原因，需要计算一个偏移量// val fontBottom = paintText.fontMetrics?.ascent ?: 0F// val fontTop = paintText.fontMetrics?.descent ?: 0F// val baseLineY = Math.abs(fontBottom + fontTop) / 2override fun onDraw(canvas: Canvas?) &#123; super.onDraw(canvas) val textLength = currentText?.length ?: 0 // font baseline val fontBottom = paintText.fontMetrics?.ascent ?: 0F val fontTop = paintText.fontMetrics?.descent ?: 0F val baseLineY = Math.abs(fontBottom + fontTop) / 2 for (i in 0 until itemNum) &#123; val left = i * (itemWith + itemGap) + paddingStart val right = i * (itemWith + itemGap) + itemWith + paddingStart val top = paddingTop.toFloat() val bottom = height - paddingBottom.toFloat() rectF.set(left, top, right, bottom) if (i &lt; textLength) &#123; // draw input string and set color for select paint paint.color = paintSelectColor val textToDraw = if (itemText.isNullOrEmpty()) currentText!![i].toString() else itemText ?: \"\" canvas?.drawText( textToDraw, left + (right - left) / 2, (top + bottom) / 2F + baseLineY, paintText ) &#125; else &#123; // set color for normal paint paint.color = paintNormalColor &#125; // draw bg as the type when (type) &#123; Type.Line -&gt; canvas?.drawLine(left, bottom, right, bottom, paint) Type.Square -&gt; canvas?.drawRoundRect(rectF, itemRadius, itemRadius, paint) &#125; &#125; &#125; 4，控件可以自定义字段 1234567891011121314&lt;declare-styleable name=\"CustomInputView\"&gt; &lt;attr name=\"item_with\" format=\"dimension\"/&gt; &lt;attr name=\"item_gap\" format=\"dimension\"/&gt; &lt;attr name=\"item_radius\" format=\"dimension\"/&gt; &lt;attr name=\"item_num\" format=\"integer\"/&gt; &lt;attr name=\"item_text\" format=\"string\"/&gt; &lt;attr name=\"normal_color\" format=\"color\"/&gt; &lt;attr name=\"select_color\" format=\"color\"/&gt; &lt;attr name=\"text_color\" format=\"color\"/&gt; &lt;attr name=\"type\" format=\"enum\"&gt; &lt;enum name=\"line\" value=\"0\"/&gt; &lt;enum name=\"square\" value=\"1\"/&gt; &lt;/attr&gt; &lt;/declare-styleable&gt; 5，继承于EditView，需要初始化一些字段 123456789101112131415// 输入类型指定为数字键盘inputType = InputType.TYPE_CLASS_NUMBERisCursorVisible = false // 光标不可见isLongClickable = false // 不能长按setTextIsSelectable(false) // 文字不能被选择复制setOnClickListener &#123; setSelection(text.length) &#125; // 点击重置光标位置，虽然不可见setBackgroundColor(UtilResource.getColor(R.color.transparent)) // 隐藏默认那根线setTextColor(UtilResource.getColor(R.color.transparent)) // 隐藏默认的文字filters = arrayOf(PinPwdFormatterFilter(itemNum)) // 设置filter，只要数字addTextChangedListener(object : DefaultTextWatcher() &#123; override fun afterTextChanged(s: Editable?) &#123; super.afterTextChanged(s) if (s.toString().length == itemNum) onInputComplete(s.toString()) &#125;&#125;) 参考文章https://www.jianshu.com/p/8b97627b21c4"},{"title":"Android cool animation","date":"2019-07-20T14:37:00.000Z","path":"2019/07/20/2019/Android cool animation  /","text":"动画用来描述一个非静态的场景。在android软件中有两种形式，1，算出初态和终态之间的插值，并在一段时间渲染播放这些状态，如animation，animator，layout transition。2，在一段时间内算法不断的绘制状态，这些状态的差异和连贯性在视觉里形成动画。一般有自定义view animation，这就是本文要记录的点。 常见方案自定义视图动画，往往是因为常规的属性动画已经无法满足设计师要求了。常见的也有三种： 效果上限 实现复杂度 工程依赖 Canvas 中等 中等 无 SVG 中等 需要专业软件制作SVG 无 Lottie 高（anything） 需要AE软件输出动画Json 需要依赖Airbnb lib SVGA 中高 需要AE软件 需要集成播放lib 可以看出想要更好的效果，投入必然需要更多：0。脑补了下要实现的操作完成动画用Canvas应该就够了。当然没有AE设计师和自己也不会sketch也是事实。 怎么搞1，得有个自定义view，复写onDraw 就有Canvas了 123456789class AnimationView : View &#123; constructor(context: Context?) : super(context) constructor(context: Context?, attrs: AttributeSet?) : super(context, attrs) constructor(context: Context?, attrs: AttributeSet?, defStyleAttr: Int) : super(context, attrs, defStyleAttr) override fun onDraw(canvas: Canvas?) &#123; super.onDraw(canvas) &#125;&#125; 2，有画布，还得需要笔 123456789private lateinit var mCirclePaint: PaintmCirclePaint = Paint(Paint.ANTI_ALIAS_FLAG) // 抗锯齿，线条流畅mCirclePaint.apply &#123; isDither = true // 动态采样 style = Paint.Style.STROKE // 线条样式 color = Color.parseColor(\"#6C9CFF\") // 画笔颜色 strokeCap = Paint.Cap.ROUND // 线头形状 strokeWidth = 30f // 线条宽度 &#125; 3，需要的动画是需要外面转圈的圆和里面的勾组成，那就先画一段弧形，弧形的长短和位置不断变化就能在视觉里形成一个转圈动画 12oval.set(0f, 0f, width - 0f, height - 0f) // 画圆弧需要设定一下ovalcanvas.drawArc(oval, 0f, -270f, false, mCirclePaint) // 画一段逆时针四分之三的圆弧 4，迈出了第一步，需要让弧形动起来 1234567// 原理就是利用ValueAnimator不断的更新属性，然后调用invalidate（）使视图重绘valueObject = ValueAnimator.ofFloat(0f, 1f) valueObject.duration = 1500L valueObject.addUpdateListener &#123; animation -&gt; animatorValue = animation.animatedValue as Float invalidate() &#125; 5，把勾也画上去，简单来讲，勾就是两条直线组成 1234// line 1canvas.drawLine(line1StartX, line1StartY, line1EndX, line1EndY, mCirclePaint)// line 2canvas.drawLine(line2StartX, line2StartY, line2EndX, line2EndY, mCirclePaint) 6，直接画两条线，效果是无比僵硬的，借鉴拍电影，我们定义几个场景点，用来描述两条线的初态和终态 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869private val ps1 = Offset(0f, 0.5f)private val ps2 = Offset(0.3f, 0.8f)private val ps3 = Offset(0.75f, 0.35f)// 这个offset的数据类重写了运算符，方便场景点计算data class Offset(val x: Float, val y: Float) &#123; operator fun minus(other: Offset): Offset &#123; return Offset(x - other.x, y - other.y) &#125; operator fun plus(other: Offset): Offset &#123; return Offset(x + other.x, y + other.y) &#125; operator fun times(time: Float): Offset &#123; return Offset(x * time, y * time) &#125;&#125;// 场景一：线条1，起始点不动，结束点从ps1往ps2运动，视觉上线条一变长，线条2不动// 场景二：线条1，起始点从ps1往ps2运动，结束点不动，视觉上线条一此时在变短，线条二结束点从ps2往ps3运动，视觉上在变长。// 场景合起来的效果就是动态的打一个勾。val line1Start = ps1 - (ps1 - ps2) * animatorValueLine1Startval line1End = ps1 - (ps1 - ps2) * animatorValueLine1Endval line2End = ps2 - (ps2 - ps3) * animatorValueLine// 用来控制场景一还是二的当然是animatorValue，用一个animatorSet来控制一下startDelayvalueObject = ValueAnimator.ofFloat(0f, 1f) valueObject.duration = 1500L valueObject.addUpdateListener &#123; animation -&gt; animatorValue = animation.animatedValue as Float invalidate() &#125;val valueSet = AnimatorSet()val valueObject2 = ValueAnimator.ofFloat(0f, 1f).apply &#123; duration = 500L startDelay = 1000L addUpdateListener &#123; animatorValueLine = it.animatedValue as Float &#125; &#125;val valueObjectLine1Start = ValueAnimator.ofFloat(0f, 0.5f).apply &#123; duration = 500L startDelay = 1000L addUpdateListener &#123; animatorValueLine1Start = it.animatedValue as Float &#125; &#125;val valueObjectLine1End = ValueAnimator.ofFloat(0f, 1f).apply &#123; duration = 500L startDelay = 500L addUpdateListener &#123; animatorValueLine1End = it.animatedValue as Float &#125; &#125;valueSet.playTogether(valueObject, valueObjectLine1Start, valueObjectLine1End, valueObject2)valueSet.addListener(onStart = &#123; animatorValueLine1Start = 0f animatorValueLine1End = 0f animatorValueLine = 0f animatorValue = 0f &#125;)valueSet.start() 细节问题1，给自定义动画加padding 123456设定Padding逻辑，一般在onlayout里做，不好做的话可以考虑不做，直接套一层viewGroup使用oval.set( 0f + paddingLeft, 0f + paddingTop, (width - paddingRight).toFloat(), (height - paddingBottom).toFloat() ) 2，给自定义动画加属性 123456789在attr中添加属性&lt;declare-styleable name=\"AnimationView\"&gt; &lt;attr name=\"paint_color\" format=\"color\"/&gt;&lt;/declare-styleable&gt;在initView中初始化数值val array = context.obtainStyledAttributes(attrs, R.styleable.AnimationView)paintColor = array.getColor(R.styleable.AnimationView_paint_color, paintColor)array.recycle() 实现效果 参考文章https://developer.android.com/training/custom-views/custom-drawing https://juejin.im/post/5bced690e51d457a7e4f8b48 https://zhuanlan.zhihu.com/p/26304609"},{"title":"Android NDK 上手指南","date":"2019-07-12T15:16:00.000Z","path":"2019/07/12/2019/Android NDK 上手指南/","text":"对于大部分android应用开发者来说，NDK开发是陌生的，很多时候只是会引用到一些so库需要写个aidl来JNI调用。最近做的一个app有媒体播放和音效处理，所以就需要上手一下NDK开发。 NDK的作用NDK是一套开发工具，通过它，就可以在android应用里调用并调试C和C++代码，特定场景下就可以做的更多更好： 需要密集计算的，如游戏或物理仿真模拟，如android早期实现实时blur效果 复用我们已经封装好的C和C++库，如io调度，引擎渲染库 环境配置为了能调试Native代码，以下组件是必须的： AndroidStudio（3.4.1）和SDK Android NDK：native开发全家桶 CMake：外部编译工具，可以搭配Gradle来编译原生库。ndk-build的备胎，已转正 LLDB：用调试原生代码的工具 认识小伙伴ndk-build看过android源码编译的会有印象，编译模块都是通过make命令来执行android.mk和Application.mk文件来构建的。 CMake在Android Studio2.2以上官方引入CMake构建系统，好处是它跨平台，而且能和Gradle无缝对接。这也是现在Android Studio默认的NDK编译工具 CMakeLists描述CMake如何将原生文件编译入库。如果导入和关联预编译库或平台库，则也需要这个编译脚本 12345678910111213141516171819202122232425cmake_minimum_required(VERSION 3.4.1)// 添加依赖库，可以是SHARED动态链接库so或STATIC静态链接库.aadd_library( # Sets the name of the library. native-lib # Sets the library as a shared library. SHARED # Provides a relative path to your source file(s). native-lib.cpp )// 依赖一些系统库find_library( # Sets the name of the path variable. log-lib # Specifies the name of the NDK library that # you want CMake to locate. log )// 链接库target_link_libraries( # Specifies the target library. native-lib # Links the target library to the log library # included in the NDK. $&#123;log-lib&#125; ) 写个Demo在不那么老的Android studio版本里选择创建New project，选Native C++一路next就能创建一个native-lib项目，so easy，感叹一下NDK的脚手架是好。 运行一下app，看到Hello from C++，来分析一下它是怎么工作的 1，app build.gradle添加cmake描述 123456externalNativeBuild &#123; cmake &#123; path \"src/main/cpp/CMakeLists.txt\" version \"3.10.2\" &#125; &#125; 2，自动生成了一个native-lib.cpp 123456// 既然是cpp，那自然是c++了，好处有两个：是c++语法更现代// - c++语法更简洁现代，比如// c++ env-&gt;NewStringUTF(hello.c_str())// c (*env)-&gt;NewStringUTF(env, hello.c_str())// - 不用命令生成头文件了，如果是c的话调用javah生成头文件然后在c文件里调用// javah com.he.test.MainActivity 3，so引入 1234// demo 工程是在MainActivity里引入的 static &#123; System.loadLibrary(\"native-lib\"); &#125; 4，那试着添加一个native方法 1234567891011// 直接在MainActivity的stringFromJNI里加一个helloFromJNIpublic native String helloFromJNI();// 这时候helloFromJNI报红，用alt+enter或者左边的智能小灯泡选择// create funtion Java_com_wuuklab_android_testjniproject_MainActivity_helloFromJNI// 这样native-lib.cpp里就自动多了一个方法可以被java调用了extern \"C\"JNIEXPORT jstring JNICALLJava_com_wuuklab_android_testjniproject_MainActivity_helloFromJNI(JNIEnv *env, jobject instance) &#123; std::string hello = \"this hello from c++\"; return env-&gt;NewStringUTF(hello.c_str());&#125; 5，单CmakeLists，多cpp 1234567# 在CmakeLists里把cpp名称加上就可以，native-test.cpp是新加的add_library( # Sets the name of the library. native-lib # Sets the library as a shared library. SHARED # Provides a relative path to your source file(s). native-lib.cpp native-test.cpp) 6，多CmakeLists，也就是带子模块 12345678910111213141516171819202122232425262728# 目录结构为|- CMakeLists.txt|- sub1 |- CMakeLists.txt |- f1.c |- f1.h|- sub2 |- CMakeLists.txt |- main.c # CMakeLists.txtcmake_minimum_required(VERSION 3.13)add_subdirectory(sub1)add_subdirectory(sub2)# sub1/CMakeLists.txtproject(sub1 C) add_library(shared_1 SHARED f1.c f1.h)target_include_directories(shared_1 PUBLIC $&#123;PROJECT_SOURCE_DIR&#125;)# sub2/CMakeLists.txt project(sub2)add_executable(exec_2 main.c)target_link_libraries(exec_2 shared_1) 参考https://developer.android.google.cn/ndk/guides/cmake http://www.leadroyal.cn/?p=781"},{"title":"String to JsonObject","date":"2019-06-28T03:28:00.000Z","path":"2019/06/28/2019/String to JsonObject/","text":"今天搞了一天JsonObject，心态爆炸，记录一下，细节还是挺好玩的 String to JsonObject12345678910// JsonParserval json = \"&#123;\"name\":\"bob\",\"age\":\"18\",\"score\":&#123;\"eng\":\"g\",\"fre\":\"h\"&#125;&#125;\"val jsonObject = JsonParser().parse(json).asJsonObjectval name = jsonObject.get(\"name\").asString // bobval scoreObject = jsonObject.getAsJsonObject(\"score\")// fromJsonval json = \"&#123;\"name\":\"bob\",\"age\":\"18\",\"score\":&#123;\"eng\":\"g\",\"fre\":\"h\"&#125;&#125;\"val jsonObject = Gson().fromJson&lt;JsonObject&gt;(json, JsonObject::class.java)val name = jsonObject.get(\"age\").asString // 18 isJsonPrimitive区别于private私有，primitive是元数据的意思，Json数据会被Gson解析成一棵LinkedTreeMap，tree上的node都是JsonElement，它有4个子类，JsonObject，JsonArray，JsonPrimitive，JsonNull。叶子节点一定是元数据JsonPrimitive或JsonNull。如果前端把一个json JSON.stringify塞到一个key里，那它就是一个叶子节点JsonPrimitive。如果需要把这个叶子节点还原成json，则需要额外parse。 12345678val json = \"&#123;\"name\":\"bob\",\"age\":\"18\",\"score\":&#123;\"eng\":\"g\",\"fre\":\"h\"&#125;&#125;\"val jsonObject = JsonParser().parse(json).asJsonObjectval scoreObject = jsonObject.getAsJsonObject(\"score\")jsonObject.addProperty(\"scorePri\", scoreObject.toString())println(jsonObject) // &#123;\"name\":\"name\",\"age\":\"age\",\"score\":&#123;\"eng\":\"g\",\"fre\":\"h\"&#125;,\"scorePri\":\"&#123;\\\"eng\\\":\\\"g\\\",\\\"fre\\\":\\\"h\\\"&#125;\"&#125;val scorePriObject = jsonObject.getAsJsonPrimitive(\"scorePri\").asStringval eng = JsonParser().parse(scorePriObject).asJsonObject.get(\"eng\").asString // g safe opration硬解json不确定key是不是null，kotlin可以用？操作符确保安全。取出来的数据也可以用isXXX来预先检查数据类型。 12345678910// nullval json = \"&#123;\"name\":\"bob\",\"age\":\"18\",\"score\":&#123;\"eng\":\"g\",\"fre\":\"h\"&#125;&#125;\"val jsonObject = JsonParser().parse(json).asJsonObjectval name = jsonObject.get(\"hobby\")?.asString // null// check type isXXXJsonElement.isJsonArrayJsonElement.isJsonObjectJsonElement.isJsonPrimitiveJsonElement.isJsonNull parse 原理无论是JsonParser还是用Gson.fromJson，本质上都是使用JsonReader解析流，了解流程可以看下hasNext和doPeek方法。"},{"title":"2018","date":"2019-04-18T13:58:00.000Z","path":"2019/04/18/2019/2018/","text":"今年经历了很多，很多的第一次，感谢生活让我丰满 工作作为移动端Leader，写的代码少了，需要思考的东西变多。主要参与并推进了这些事： 外卖敏捷小组EO，并上线 外卖小组和移动端OKR推进未落实 再惠合伙人App RN版上线 Flutter技术栈引入，并重构再惠合伙人App 工程师文化建设，消除iOS，android工程师意识隔阂；组织大家技术分享和Blog输出 OKR从结果上来看并没啥用，是值得深思的事儿。敏捷小组流程引入好处是产品开发节奏更好控制，坏处是工程师积极性有负面影响。以前产品一有问题，大家不论前后端都会扑上去看，分了以后就没见过这个画面了。 生活两人在一起久了，就会把自己最真实的一面毫无保留的曝露出来，这时难免需要磨合并重新了解一下彼此。日常点滴，都是以后的回忆。 3月和女票，合租室友一块去陈行公园玩，春风和煦，好不放松，虽然是个小公园，但由于各种原因，竟然是上半年唯一去的公园。 4月清明回家扫墓，自从毕业后就没回去扫墓了，对于普通来说人会分两次消失，一次是肉体死亡，在物理上被这个世界除名，一次精神上死亡，当所有人记忆中都没有这个人时，他的存在也就被彻底抹去了。清明就是这样一种形式，给自己的亲人拔拔草，松松土，记忆有份传承。 5月女票爸比生日，我们合伙买了个大金链子贺寿，未来女婿好感值+1。顺便去看了一下装修公司，对比下来选了一家全包的。 6月公司挪位置，来了新CTO一起团建，端午自驾游去崇明岛，期间烧烤，露营，打牌，骑马，好不放松。 7月对车不友好，导航数据4s来回弄都有问题，期间还把车灯给擦了，好消息是我们要变成我们仨了。 9月和女票去定了婚晒照，期间去了嘉定马陆去摘葡萄。 十一回株洲参加了她两个大学室友的婚礼，想着我们的也快了。 11月，我们小组团建去迪士尼玩。拍完婚纱照，领了结婚证，嗯，是时候改口叫老婆了。 12月，我们结婚啦！ 2月，公司组织了管理培训大会，有收获也觉得有些东西有点虚。 3月，前端大佬JGG去拯救阿里小程序了。 感谢移动端小伙伴的专注和努力，让我们可以建立背靠背的信任。 CTO华哥的支持，让我们有机会在早期上Flutter。 感谢爸妈，岳父母，妹妹，弟弟，婚礼的辛苦操持。 感谢老婆，当妈的不易，若非亲受，难以理解。 展望随着小家伙的到来，工作生活需要一个新的开始！"},{"title":"Fish Redux 使用指南","date":"2019-03-16T12:41:00.000Z","path":"2019/03/16/2019/Fish redux/","text":"为啥要使用Fish redux1，年前就被咸鱼大佬安利，种草已久2，想要对比Flutter Redux，学习体会它带来的优越性3，参与并支持一下国产，现在Flutter生态还在早期 准备工作1，Redux.js 文档 2，Fish Redux 文档 3，Pub使用文档 萌新（没接触过Redux）：建议按顺序看一遍，磨刀不费砍柴功，扎实的理论基础是很有用处的 熟练玩家（Demo用过Redux）：建议把Fish Redux文档的简介和Component看下，尤其是Component，这是它独特的地方 老司机（项目中用过Redux.js或Flutter Redux）：可以重点看下Component中的Effect，Dependencies，Page，还有Adapter 在看文档时，可以把Fish Redux项目Clone下来，先把Example改下跑跑看，再对着源码理解下文档中的概念。 重要概念当然以下概念还是需要理解的： ActionAction定义一种行为，可以携带信息，发往Store。换言之Store发生改变须由Action触发，Fish redux 有以下约定：Action 包含两个字段type和payload；推荐写法是在action.dart里定义一个type枚举类和一个ActionCreator类，这样有利于约束payload的类型。 Reducer/Effect这两个函数都是用来处理数据的函数，Reducer是纯函数响应Action对Store数据进行改变。Effect用来处理来自视图的意图，如点击事件，发起异步请求，这些有副作用的操作。 Page可以看成是一个容器，它用来配置聚合State，Effect，Reduce，View，Dependencies等 一个页面内都有且仅有一个 Store（意思是会有好多个Store，这是区别于Flutter Redux的） Page 继承于 Component，所以它能配置所有 Component 的要素（意思是比Component多了Middleware和initState） Page 能配置 Middleware，用于对 Redux 做 AOP 管理（意思是可以无侵入的实现一些如log打印，性能分析这样的通用功能。中间件定义是可插拔，可叠加，但不会改变事件流程） Page 必须配置一个初始化页面数据的初始化函数initState（页面有初始数据是必须的吧） Adapter（可选）这个不是必须，但确实很屌，很好用，使用和Android的老配方差不多，妙在效果拔群。有追求的可以看下历史和原理，当然还有源码。 有这些储备，那么可以开始写代码了 接入1，创建一个flutter project，按照文档加入依赖 2，按照定义（当然也可以对着Example）分别创建Action，State，Effect，Reducer，View，Page这几个文件，并写套路代码。 3，运行代码观察效果 个人体验1，集中，分治 Fish Redux完整复刻了Redux.js的核心概念，状态是一颗State树，完整体现[Predictable],[Centralized],[Debuggable],[Flexible]，数据状态是由Redux集中管理的。分治是分而治之，把一个大的问题拆解成若干独立的小问题去解决，比如Effect的实现和Component的封装，一个页面可以由多个Component和Effect共同组成，分治带来的一个额外好处是提高了内聚性和可复用性。 2，Adapter 个人人为这是咸鱼团队基于现实业务的一个很重要创造，Listview可以占到一个应用的50%以上界面，它的体验至关重要。事实证明Adapter封装的很友好，性能也很突出，在Demo上就可以明显对比出来，很妙。 3，文档 这点是可以理解一下的，毕竟刚开源。现状是注释少，好多模块还没有。文档有，但不太具体生动，友好，读者没带入容易字都认识，但看几遍还不解其意。 问题1，Fish Redux 一个页面一个Store的资源开销？ 2，Store的生命周期，应用的一些长期共用数据怎么维护？ DEMO"},{"title":"Flutter Redux 进阶","date":"2018-12-09T15:08:00.000Z","path":"2018/12/09/2018/Flutter redux 进阶/","text":"目的 认识Flutter Redux局限性 引入Middleware必要性 全方位集成UT Flutter Redux初代实现局限性UT不好覆盖 页面 初代实现一个页面的结构是这样的： 1234567891011121314class XXXScreen extends StatefulWidget &#123; @override _XXXScreenState createState() =&gt; _XXXScreenState();&#125;class _XXXScreenState extends State&lt;XXXScreen&gt; &#123; @override Widget build(BuildContext context) &#123; return StoreConnector&lt;AppState, _XXXViewModel&gt;( converter: (store) =&gt; _XXXViewModel.fromStore(store), builder: (BuildContext context, _XXXViewModel vm) =&gt; Container()); &#125;&#125; 会有两个问题：UI视图和Redux数据通用逻辑耦和在一起，无发通过mock数据来对UI进行UT；大家习惯套路代码，上来就是一个stful，不会想是不是stless更科学点（事实上初代实现80%的Screen是Statefull的，重构后90%都能写成Stateless，提升了页面刷新效率）。 API call 我们的API就是一个静态方法： 12345678910static fetchxxx() &#123; final access = StoreContainer.access; final apiFuture = Services.rest.get('/zpartner_api/$&#123;access.path&#125;/$&#123;access.businessGroupUid&#125;/xxxx/'); Services.asyncRequest( apiFuture, xxxRequestAction(), (json) =&gt; xxxSuccessAction(payload: xxxInfo.fromJson(json)), (errorInfo) =&gt; xxxFailureAction(errorInfo: errorInfo));&#125; 优点是简单，有java味，缺点是：静态方法无法使用mockIto；一个Api call触发，那就发出去了，无法撤销无法重试；自然也无法进行UT覆盖。 不够Functional上面提到的页面和API call都体现了不Functional，还有我们初代Reducer的写法也是大家很熟悉的OO写法123456789101112131415class xxxReducer &#123; xxxState reducer(xxxState state, ActionType action) &#123; switch (action.runtimeType) &#123; case xxxRequestAction: return state.copyWith(isLoading: ); case xxxSuccessAction: return state.copyWith(isLoading: ); case xxxFailureAction: return state.copyWith(isLoading: ); default: return state; &#125; &#125;&#125; 从上到下流水写法，static，switch case这都是我们OO的老朋友。但既然Dart是偏前端特性，Functional才是科学的方向啊。 引入Middleware必要性 业务已经写完，小伙伴边自测边写UT，为了达到50%的coverage可以说是非常蛋疼了。某大佬眉头一皱发现问题并不简单，UT不好写，是不是结构搓？于是召集大家讨论一波，得出这些局限性。改还是不改是个问题，不改开发算是提前完成，反正Rn也没有写UT；改的话，改动量是巨大的。大家都停下手中的工作，思考并深刻讨论这个问题，于是我们从三个方向衡量这个问题： 业务影响离排期提测时间只有1个星期，加入Middleware会有80%的代码需要挪动，改完还要补UT，重新自测。emmm，工作量超大。和产品沟通了下，其实这个业务就是技术重构性质，线上Rn多跑一个礼拜也无碍，测试组也恰好特别忙，delay一周他们觉得ok。倾向改。 技术栈影响从长远看，改动是进步的。对UT友好，更严谨的结构，也更Functional。小伙伴们觉得自己也能驾驭，不过是多写点套路代码～，技术栈倾向改。 伙伴支持度引入Middleware带来的好处能否让小伙伴愿意加班把自己的模块都改写了，还补上UT？实践出真知，所以大家讨论决定，用半天时间理解并改写一个小模块，再投票决定是否改。讨论很激烈，话题一度跑偏。。。 讨论下来，最终决定是改，一星期后大家都说，真香！ 改动点增删 删掉原来Service的static API定义，加入Middleware和Repository。Middleware负责网络请求，数据处理，并根据数据状态进行Action的分发。Repository功能是定义了一个数据来源（可能来源于网络，也可能是数据库），因为引入Dio，所以会很精简，形式上可以看成是一个Endpoint定义。 Middleware 12345678910111213141516171819class XXXMiddlewareFactory extends MiddlewareFactory &#123; XXXMiddlewareFactory(AppRepository repository) : super(repository); @override List&lt;Middleware&lt;AppState&gt;&gt; generate() &#123; return [ TypedMiddleware&lt;AppState, FetchAction&gt;(_fetchXXX), ]; &#125; void _fetchXXX(Store&lt;AppState&gt; store, FetchAction action, NextDispatcher next) &#123; Services.asyncRequest( () =&gt; repository.fetch(), FetchRequestAction(), (json) =&gt; FetchSuccessAction(), (errorInfo) =&gt; FetchFailureAction(errorInfo: errorInfo)); &#125;&#125; Repository 1234Future&lt;Response&gt; fetchXXX(String uid) &#123; return Services.rest.get( '/xxx_api/$&#123;path&#125;/$&#123;groupUid&#125;/manual_activities/$uid/');&#125; 修改 Screen把UI都抽到Presentation里，它依赖一个vm。数据填充并驱动UI变化，这样UI也可以写很全面的UT。Reducer则是利用Flutter_redux库提供的combineReducers方法，将原来一个大的Reducer粒度切到最小。方便写UT和业务增量迭代。 Screen 1234567891011121314151617181920212223242526272829303132333435class XXXPresentation extends StatelessWidget &#123; final XXXViewModel vm; const XXXPresentation(&#123;Key key, this.vm&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return Container(); &#125;&#125;class XXXScreen extends StatelessWidget &#123; static const String routeName = 'xxx_screen'; @override Widget build(BuildContext context) &#123; return StoreConnector&lt;AppState, XXXViewModel&gt;( distinct: true, onInit: (store) &#123; store.dispatch(FetchXXXAction(isRefresh: true)); &#125;, onDispose: (store) =&gt; store.dispatch(XXXResetAction()), converter: XXXViewModel.fromStore, builder: (context, vm) &#123; return XXXPresentation(vm: vm); &#125;, ); &#125;&#125;class XXXViewModel &#123; static XXXViewModel fromStore(Store&lt;AppState&gt; store) &#123; return XXXViewModel(); &#125;&#125; Reducer 12345678910111213141516171819202122232425@immutableclass XXXState &#123; final bool isLoading; XXXState(&#123;this.isLoading, &#125;); XXXState copyWith(&#123;bool isLoading, &#125;) &#123; return XXXState( isLoading: isLoading ?? this.isLoading, ); &#125; XXXState.initialState() : isLoading = false;&#125;final xXXReducer = combineReducers&lt;XXXState&gt;([ TypedReducer&lt;XXXState, Action&gt;(_onRequest),]);XXXState _onRequest(XXXState state, Action action) =&gt; state.copyWith(isLoading: false); UT集成 现在的coverage是48%，核心模块有80%+，有必要的话达到95%以上时完全ok的。原因是解耦以后方方面面都可以UT了 widget(纯) 12// 官方文档写的清楚明白https://flutter.io/docs/testing Utils 被多次使用的才会抽成工具类，纯逻辑也很容易写测试，UT应该先满上。 123456789101112131415group('test string util', () &#123; test('isValidPhone', () &#123; var boolNull = StringUtil.isValidPhone(null); var boolStarts1 = StringUtil.isValidPhone('17012341234'); var boolStarts2 = StringUtil.isValidPhone('27012341234'); var boolLength10 = StringUtil.isValidPhone('1701234123'); var boolLength11 = StringUtil.isValidPhone('17012341234'); expect(boolNull, false); expect(boolStarts1, true); expect(boolStarts2, false); expect(boolLength10, false); expect(boolLength11, true); &#125;);&#125; Presentation 业务的载体。对于比较核心的业务，无论是流程规范定义还是数据边界条件都可以用UT来自动化保障。 1234567891011121314151617181920group('test login presentation', () &#123; Store&lt;AppState&gt; store; setUp(() &#123; store = Store&lt;AppState&gt;(reduxReducer, initialState: initialReduxState(), distinct: true); StoreContainer.setStoreForTest(store); &#125;); testWidgets('test loading', (WidgetTester tester) async &#123; final vm = LoginViewModel(isLoading: true, isSendPinSuccess: false); await TestHelper.pumpWidget(tester, store, LoginPresentation(vm: vm)); expect(find.byType(CupertinoActivityIndicator), findsOneWidget); ... &#125;); testWidgets('test has data',(WidgetTester tester) async &#123; ... &#125;); testWidgets('test has no data',(WidgetTester tester) async &#123; ... &#125;); &#125; Reducer 存放数据，可以用UT来验证特定Action是否改变了特定的数据。 1234567891011121314group('notificationReducer', () &#123; test('FetchMessageUnreadRequestAction', () &#123; store.dispatch(FetchMessageUnreadRequestAction()); expect(store.state.notification.isLoading, true); &#125;); test('FetchMessageUnreadSuccessAction', () &#123; final payload = MessageUnreadInfo.initialState(); store.dispatch(FetchMessageUnreadSuccessAction(payload: payload)); expect(store.state.notification.messageUnreadInfo, payload); expect(store.state.notification.isLoading, false); &#125;); ...&#125; Middleware 叫中间件代表它不是必须，是可以被插拔，可以叠加多个的。每个中间件会有一个明确的任务，我们引入的中间件在这里是处理网络数据，根据情况发对应Action。 123456789101112131415161718192021222324group('Middleware', () &#123; final repo = MockAppRepository(); Store&lt;AppState&gt; store; setUpAll(() async &#123; await mockApiSuc(repo); &#125;); setUp(() &#123; store = Store&lt;AppState&gt;(reduxReducer, initialState: initialReduxState(), middleware: initialMiddleware(repo), distinct: true); StoreContainer.setStoreForTest(store); &#125;); group('NotificationMiddlewareFactory', () &#123; test('FetchMessageUnreadAction', () &#123; store.dispatch(FetchMessageUnreadAction()); verify(repo.fetchMessagesUnread()); &#125;); test('FetchMessageForHomeAction', () &#123; store.dispatch(FetchMessageForHomeAction()); verify(repo.fetchMessagesForHome()); &#125;); ... &#125; 参考flutter_redux_sample flutter_architecture_samples One More Thing TNT，让你的工作效率提高几百倍，老罗认真严肃的说。开个玩笑，这个有待验证。但Live Templates，提升你的编程效率和体验，肯定是真的 使用地址：https://github.com/hui-z/live-templates （完）"},{"title":"Flutter Redux","date":"2018-11-24T14:45:00.000Z","path":"2018/11/24/2018/Flutter redux/","text":"目的 Redux是什么 Redux在Flutter里的作用 Flutter里如何使用Redux 效果Flutter App本质上是一个单页面应用，需要我们自己维护State，Model，Route。随着业务的增加，这些工作会变得很复杂，也不可预测，复现一个bug会很困难，跨组件传递数据也很难。Redux思想继承于Flux，通过合理的约定让业务分层解耦，数据的变动可以预测，可以重现。Redux有三个原则： 1.单一的数据来源（App统一的Store） 2.状态State是只读的（数据不能直接修改，只能用过约定的Action触发，Reduce修改） 3.数据改动须是纯函数（这些纯函数叫Reducer，定义了如何修改Store，由Action触发） 原理Redux（3.0.0）是作者用Dart把JS 的redux库实现了，它定义了Store，Action，Reduce，Middleware以及它们之间的行为关系。 flutter_redux（0.5.2）作为工具类桥接Redux和Flutter，它提供了StoreProvider，StoreBuilder，StoreConnector这些组件，使我们在flutter中使用redux变的很简便。 流程图 ActionAction定义一种行为，可以携带信息，发往Store。换言之Store发生改变须由Action触发。Live Template快捷键ac，创建一套Api Aciton： 1234567891011class xxxRequestAction extends VoidAction &#123;&#125;class xxxSuccessAction extends ActionType &#123; final payload; xxxSuccessAction(&#123;this.payload&#125;) : super(payload: payload);&#125;class xxxFailureAction extends ActionType &#123; final RequestFailureInfo errorInfo; xxxFailureAction(&#123;this.errorInfo&#125;) : super(payload: errorInfo);&#125; APIApp功能最小粒度依赖是API，一般我们前后端会约定一套Rest接口定义。这里APP端是用一个静态方法封装实现的，里面定义了Path，Request，Success，Failure三个Action的响应回调。 12345678910static fetchxxx() &#123; final access = StoreContainer.access; final apiFuture = Services.rest.get('/zpartner_api/$&#123;access.path&#125;/$&#123;access.businessGroupUid&#125;/xxxx/'); Services.asyncRequest( apiFuture, xxxRequestAction(), (json) =&gt; xxxSuccessAction(payload: xxxInfo.fromJson(json)), (errorInfo) =&gt; xxxFailureAction(errorInfo: errorInfo));&#125; Reduce&amp;stateState是Store的一个节点，定义了这个节点的数据申明，Reduce每一次响应Action都会创建一个新的State去替换原来Store里的那个节点State。Reduce和State基本上是一对一的，所以把他们放在一个文件里。Live Template快捷键rd，创建一套Reduce&amp;State： 1234567891011121314151617181920212223242526272829@immutableclass xxxState &#123; final bool isLoading; xxxState(&#123;this.isLoading&#125;); xxxState copyWith(&#123;bool isLoading&#125;) &#123; return xxxState(isLoading: isLoading ?? this.isLoading); &#125; xxxState.initialState() : isLoading = false; &#125;class xxxReducer &#123; xxxState reducer(xxxState state, ActionType action) &#123; switch (action.runtimeType) &#123; case xxxRequestAction: return state.copyWith(isLoading: ); case xxxSuccessAction: return state.copyWith(isLoading: ); case xxxFailureAction: return state.copyWith(isLoading: ); default: return state; &#125; &#125;&#125; Middleware中间件，插在Action触发后还没有到达Reduce之间执行，一般是用来做一些API异步请求并处理。这一步是可选的，当时鉴于Dio网络库对数据有Json处理，flutter_epic表现也还不够稳定。所以我们没用Middleware而是封装了一个工具方法在API services里直接调用处理API并且根据结果分发对应Action。有接入集成测试的需要，需要重点考虑是否引入它。 进阶全局ActionApp里的登出操作是比较特殊的，它可能在不同模块被调起，而且需要做的操作是清空整个Store。我们用了一个GlobalReduce去分发Action 12345678910111213141516AppState reduxReducer(AppState state, action) =&gt; GlobalReducer().reducer(state, action);class GlobalReducer &#123; AppState reducer(AppState state, ActionType action) &#123; switch (action.runtimeType) &#123; case AppRestartAction: hasToken(); return _initialReduxState(); default: return AppState( login: LoginReducer().reducer(state.login, action), ...) &#125; &#125;&#125; APIFuction前面提到我们没有使用Middleware，而是自己封装了一个工具Function，好处是简单易用，缺点是没有明确返回值不好写测试，利弊需要权衡下的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/// common function for network with dio/// Future&lt;Response&gt; apiFuture [Dio.request]/// request action/// success action/// failure actionstatic asyncRequest( Future&lt;Response&gt; apiFuture, ActionType request, ActionType Function(dynamic) success, ActionType Function(RequestFailureInfo) failure,) async &#123; // request StoreContainer.global.dispatch(request); final requestBegin = DateTimeUtil.dateTimeNowMilli(); try &#123; final response = await apiFuture; final requestEnd = DateTimeUtil.dateTimeNowMilli(); final requestSpend = requestEnd - requestBegin; if (requestSpend &lt; requestMinThreshold) &#123; await Future.delayed(Duration( milliseconds: requestMinThreshold - requestSpend)); // 请求返回太快，页面有点卡顿，有点尴尬 todo &#125; // success StoreContainer.global.dispatch(success(response.data)); &#125; on DioError catch (error) &#123; var message = ''; var code = '-1'; var url = ''; if (error.response != null) &#123; var errorData = error.response.data; List messageList = errorData is Map&lt;String, dynamic&gt; ? ((errorData['message']) ?? []) : []; messageList .forEach((item) =&gt; message = message + item.toString() + ' '); code = error.response.statusCode.toString(); url = error.response.request.baseUrl + error.response.request.path; &#125; else &#123; message = error.message; &#125; final model = RequestFailureInfo( errorCode: code, errorMessage: message, dateTime: DateTimeUtil.dateTimeNowIso()); // failure StoreContainer.global.dispatch(failure(model)); &#125;&#125; 局部刷新使用flutter_redux提供的StoreConnector组件时，可以设置distinct为ture，Store变化后是否刷新视图可以完全自己控制。原理是需要重载ViewModel的==运算符和重写hashcode方法。这样在Store变化时，StoreStreamListener通过比对前后两个ViewModel是否相等来触发是否重新builder，而这个是否相等都是我们重写并自己控制的。 123456789101112131415161718192021222324252627class _RestartAppViewModel &#123; Key key; bool isLogin; _RestartAppViewModel(&#123;this.key, this.isLogin&#125;); static _RestartAppViewModel fromStore(Store&lt;AppState&gt; store) =&gt; _RestartAppViewModel( key: store.state.cache.key, isLogin: store.state.cache.isLogin); @override int get hashCode =&gt; key.hashCode ^ isLogin.hashCode; @override bool operator ==(other) =&gt; identical(this, other) || other is _RestartAppViewModel &amp;&amp; key == other.key &amp;&amp; isLogin == other.isLogin;&#125;StoreConnector&lt;AppState, _RestartAppViewModel&gt;( distinct: true, builder: (context, vm) &#123; return App(vm.isLogin, vm.key); &#125;, converter: (store) =&gt; _RestartAppViewModel.fromStore(store)) 参考https://github.com/johnpryan/redux.dart/tree/master/doc （完）"},{"title":"Flutter BottomNavigationBar","date":"2018-11-08T14:28:00.000Z","path":"2018/11/08/2018/Flutter Bottom Navigation Bar/","text":"底部导航是常见的APP布局方式，实际上我自己常用的app都是底部导航的。Android和iOS都有官方组件可供使用。Flutter也有，使用时有踩坑，这里记录一下。 一般用法普通实现: 1234567891011121314BottomNavigationBar botttomNavBar = BottomNavigationBar( items: [ BottomNavigationBarItem(icon: Icon(Icons.code), title: Text(&apos;code&apos;)), BottomNavigationBarItem(icon: Icon(Icons.add), title: Text(&apos;add&apos;)), BottomNavigationBarItem(icon: Icon(Icons.print), title: Text(&apos;print&apos;)) ], currentIndex: _currentIndex, type: BottomNavigationBarType.fixed, onTap: (int index) &#123; setState(() &#123; _currentIndex = index; &#125;); &#125;,); 问：看起来很简单，至于分析这么多吗？ 答：emmmm，这实现优点是设计标准规范，官方组件也简单稳定可靠。但前提是设计师接受这种设定（即使是fixed，选中图标和文字也会有放大缩小动画），至少中国主流的APP，navigation item都是fixed而且没有动画，官方组件并不提供这种选择。 有点问题既然设计师有要求那不能怂，分析是因为内部的_BottomNavigationTile作祟，那自己实现navigationItem控制是否选中，并且不传currentIndex给BottomNavigationBar，应该可以吧 123456789101112131415161718192021222324252627282930313233Widget _buildBottomNavigationBar() &#123; return BottomNavigationBar( type: BottomNavigationBarType.fixed, items: [ _buildItem(icon: Icons.code, tabItem: TabItem.code), _buildItem(icon: Icons.add, tabItem: TabItem.add), _buildItem(icon: Icons.print, tabItem: TabItem.print), ], onTap: _onSelectTab, );&#125;// 用定制化的icon和tabItem构建BottomNavigationBarItemBottomNavigationBarItem _buildItem(&#123;IconData icon, TabItem tabItem&#125;) &#123; String text = tabItemName(tabItem); return BottomNavigationBarItem( icon: Icon( icon, color: _colorTabMatching(item: tabItem), ), title: Text( text, style: TextStyle( color: _colorTabMatching(item: tabItem), ), ), );&#125;// 切换item的颜色，选中用primaryColor，其他都是grey Color _colorTabMatching(&#123;TabItem item&#125;) &#123; return currentItem == item ? Theme.of(context).primaryColor : Colors.grey;&#125; 问：效果如何？ 答：嗯，不错。等等。。。啊，怎么有个大一点。没道理啊，事出蹊跷必有妖，需要从源码中找答案了。下图的home明显比mail大，对吧？ 源码阅读主要代码都在bottom_navigation_bar.dart里，bottom_navigation_bar_item.dart是item的定义 bottom_navigation_bar_item.dart 相当于是一个自定义的Button，用来放在BottomNavigationBar上，它实现了Material(Android)和Cupertino(iOS)两种风格。 bottom_navigation_bar.dart Scaffold是Root Widget- MaterialApp的脚手架。封装了Material Design App会用到的AppBar，Drawer，SnackBar，BottomNavigationBar等。BottomNavigationBarType有fixed 和shifting两种样式，超过\u0010\u0010\u00103个才会有区别，一般为了体验一致，我们会用fixed type。 BottomNavigationBar是一个StatefulWidget，可以按以下步骤分析这种组件：1，先看它持有的状态，2，看下他的生命周期实现，3，再仔细分析它的build方法。 持有状态 123456789List&lt;AnimationController&gt; _controllers = &lt;AnimationController&gt;[];List&lt;CurvedAnimation&gt; _animations;// A queue of color splashes currently being animated.final Queue&lt;_Circle&gt; _circles = Queue&lt;_Circle&gt;();// Last splash circle's color, and the final color of the control after// animation is complete.Color _backgroundColor; 前面三个属性都和动画相关，第四个是设背景。 问：BottomNavigationBar为什么没有变量标记当前哪个item选中？ 答：函数式编程一个原则是要函数尽量纯，currentIndex这个属性依赖外边传入，每次变化重新触发Render。如果自己维护，则还需要提供一个回调方法供外部调用，返回最新的currentIndex值。 生命周期方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 初始化操作，具体实现再resetState里，对上面的这些状态属性初始化操作@overridevoid initState() &#123; super.initState(); _resetState();&#125;// 回收资源操作，一般用到动画都需要的@overridevoid dispose() &#123; for (AnimationController controller in _controllers) controller.dispose(); for (_Circle circle in _circles) circle.dispose(); super.dispose(); &#125;// 当属性变化时Flutter系统回调该方法。当item数量变化时直接重新初始化；当index变化，做相应动画。@overridevoid didUpdateWidget(BottomNavigationBar oldWidget) &#123; super.didUpdateWidget(oldWidget); // No animated segue if the length of the items list changes. if (widget.items.length != oldWidget.items.length) &#123; _resetState(); return; &#125; if (widget.currentIndex != oldWidget.currentIndex) &#123; switch (widget.type) &#123; case BottomNavigationBarType.fixed: break; case BottomNavigationBarType.shifting: _pushCircle(widget.currentIndex); break; &#125; _controllers[oldWidget.currentIndex].reverse(); _controllers[widget.currentIndex].forward(); &#125; if (_backgroundColor != widget.items[widget.currentIndex].backgroundColor) _backgroundColor = widget.items[widget.currentIndex].backgroundColor; &#125;// 下面分析@overrideWidget build(BuildContext context) &#123;&#125; 注意：initState里有个操作比较隐蔽：_controllers[widget.currentIndex].value = 1.0; 分析build方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@override Widget build(BuildContext context) &#123; // debug 检查 assert(debugCheckHasDirectionality(context)); assert(debugCheckHasMaterialLocalizations(context)); // Labels apply up to _bottomMargin padding. Remainder is media padding. final double additionalBottomPadding = math.max(MediaQuery.of(context).padding.bottom - _kBottomMargin, 0.0); // 根据BottomNavigationBarType设背景色，shifting才会有 Color backgroundColor; switch (widget.type) &#123; case BottomNavigationBarType.fixed: break; case BottomNavigationBarType.shifting: backgroundColor = _backgroundColor; break; &#125; return Semantics( // Semantics用来实现无障碍的 container: true, explicitChildNodes: true, child: Stack( children: &lt;Widget&gt;[ Positioned.fill( child: Material( // Casts shadow. elevation: 8.0, color: backgroundColor, ), ), ConstrainedBox( constraints: BoxConstraints(minHeight: kBottomNavigationBarHeight + additionalBottomPadding), child: Stack( children: &lt;Widget&gt;[ Positioned.fill( // 点击时的圆形类波纹动画 child: CustomPaint( painter: _RadialPainter( circles: _circles.toList(), textDirection: Directionality.of(context), ), ), ), Material( // Splashes. type: MaterialType.transparency, child: Padding( padding: EdgeInsets.only(bottom: additionalBottomPadding), child: MediaQuery.removePadding( context: context, removeBottom: true, // tiles就是_BottomNavigationTile，里面放BottomNavigationBarItem child: _createContainer(_createTiles()), )))]))])); &#125;&#125; _BottomNavigationTile看下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 Widget _buildIcon() &#123; ... // 构建Iocn &#125; Widget _buildFixedLabel() &#123; .... // 骚操作，用矩阵来给文字作动画，更平滑 // The font size should grow here when active, but because of the way // font rendering works, it doesn't grow smoothly if we just animate // the font size, so we use a transform instead. child: Transform( transform: Matrix4.diagonal3( Vector3.all( Tween&lt;double&gt;( begin: _kInactiveFontSize / _kActiveFontSize, end: 1.0, ).evaluate(animation), ), ), alignment: Alignment.bottomCenter, child: item.title, ), ), ), ); &#125; Widget _buildShiftingLabel() &#123; return Align(..... // shifting的label是fade动画，只有当前选中的才会显示label child: FadeTransition( alwaysIncludeSemantics: true, opacity: animation, child: DefaultTextStyle.merge( style: const TextStyle( fontSize: _kActiveFontSize, color: Colors.white, ), child: item.title, ), ), ), ); &#125; @override Widget build(BuildContext context) &#123; int size; Widget label; // 生成不同的label switch (type) &#123; case BottomNavigationBarType.fixed: size = 1; label = _buildFixedLabel(); break; case BottomNavigationBarType.shifting: size = (flex * 1000.0).round(); label = _buildShiftingLabel(); break; &#125; return Expanded( .... children: &lt;Widget&gt;[ _buildIcon(), label, ], ), ), Semantics( label: indexLabel,&#125; 改进实现通过分析分析源码，发现原因是bottomNavigationBarState的initState里_controllers[widget.currentIndex].value = 1.0设了currentIndex item动画的初值，currentIndex的默认值是0，所以第一个图标会大一点点。这个问题也有比较鸡贼的手法可以处理（魔改源码什么～），但这样大家都觉得不妥。同事眉头一皱，做了一个大胆的决定，不用系统组件BottomNavigationBar，自己封装一下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// SafeArea来兼容下iPhone X，android和iOS阴影不一样，所以区分下。Widget _buildBottomNavigationBar() &#123; return SafeArea( child: SizedBox( height: 50.0, child: Card( color: Platform.isIOS ? Colors.transparent : Colors.white, elevation: Platform.isIOS ? 0.0 : 8.0, // iphone 无阴影 shape: RoundedRectangleBorder(), margin: EdgeInsets.all(0.0), child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Divider(), Expanded( child: Row( mainAxisAlignment: MainAxisAlignment.center, crossAxisAlignment: CrossAxisAlignment.center, children: &lt;Widget&gt;[ _buildBottomItem( image: HImages.home, text: '首页', index: 0), _buildBottomItem( image: HImages.stats, text: '数据', index: 1), _buildBottomItem( image: HImages.mine, text: '我的', index: 3) ]), ) ]))));&#125;// 封装的BottomItem，选中颜色为primaryColor，未选中grey。点击波纹效果InkResponseWidget _buildBottomItem(&#123;String image, String text, int index&#125;) &#123; Color color = currentIndex == index ? Theme.of(context).primaryColor : Colors.grey; return Expanded( child: InkResponse( child: Column( mainAxisAlignment: MainAxisAlignment.center, crossAxisAlignment: CrossAxisAlignment.center, children: &lt;Widget&gt;[ Image.asset(image, color: color, width: 22.0, height: 22.0), Text(text, style: TextStyle(color: color, fontSize: 10.0)) ]), onTap: () =&gt; setState(() =&gt; currentIndex = index)));&#125; 问：这该是最终版了吧？* 答：Naive，是连iPhone X都考虑了，但细节渐变颜色，platform特性支持还没有。。。说到特性我就佛了，一佛，我就想起西天取经，明年年初，中美合拍的西游记即将正式开机，我继续扮演美猴王孙悟空，我会用美猴王艺术形象努力创造一个正能量的形象，文体两开花，弘扬中华文化，希望大家多多关注。 一些收获 组件动画实现可以参考BottomNavigationBar，规范， 文字动画实现可以用Matrix4和Vector3，比较高级（这个在TabBar用上了）， 考虑给官方提个issue（需求比较区域化）。 本文源码地址：https://github.com/hyjfine/flutter-play （完）"},{"title":"Flutter Theme","date":"2018-10-15T06:51:00.000Z","path":"2018/10/15/2018/Flutter Theme/","text":"主题（Theme）在软件开发里 属于高级追求，Mac OS经过多年演化后终于在macOS Mojave中加入深色主题，可以让你做起事来更专注。 作用 取悦用户，白菜萝卜给用户更多个性化选择 提升效率，比如深色主题让人更专注，演示模式让内容更突出 组成主题（Theme）一般是由color，BG image，fontSize，font等资源组成 Android/iOSandroid应用资源都在资源路径src/res下，style相关改动可以通过activity的setTheme来切换，图片换肤一般会将资源打成一个不带launcher icon的Apk，用Resource实例去加载特定资源；而iOS相应的配置信息都预先写在plist文件里，通过一个ThemeManager实例来控制应用使用哪套资源配置。 FlutterMaterialApp组件接受一个theme参数，通过改变theme的数据，组件会实时重新渲染 Flutter Theme实现Flutter UI也是树形结构。每个节点都是一个widget，根（Root）节点是WidgetsApp，MaterialApp，CupertinoApp之一。Flutter的特色就是对Material design进行了高质量的实现，所以为了更便利的使用这些内置组件，通常是会用MaterialApp widget作为根组件，它也是唯一提供Theme支持的根组件。Theme的类型是ThemeData，它的接受的定义如图所示：实际上我们只会定义一些有关的属性，举个例子Flutter sdk example，gallery。它定义了Dark和Light两套主题： 12345678910111213141516171819202122232425262728293031323334353637383940414243ThemeData _buildDarkTheme() &#123; const Color primaryColor = Color(0xFF0175c2); final ThemeData base = ThemeData.dark(); return base.copyWith( primaryColor: primaryColor, // 应用主颜色 buttonColor: primaryColor, // 按钮颜色 indicatorColor: Colors.white, // 指示器颜色 accentColor: const Color(0xFF13B9FD), // 突出颜色 canvasColor: const Color(0xFF202124), // 画布颜色 scaffoldBackgroundColor: const Color(0xFF202124), // 返回键按钮 backgroundColor: const Color(0xFF202124), // 背景色 errorColor: const Color(0xFFB00020), // 错误色 buttonTheme: const ButtonThemeData( textTheme: ButtonTextTheme.primary, ), // 按钮主题 textTheme: _buildTextTheme(base.textTheme), // 普通文本主题 primaryTextTheme: _buildTextTheme(base.primaryTextTheme), // 主文本主题 accentTextTheme: _buildTextTheme(base.accentTextTheme), // 强调文本主题 );&#125;ThemeData _buildLightTheme() &#123; const Color primaryColor = Color(0xFF0175c2); final ThemeData base = ThemeData.light(); return base.copyWith( primaryColor: primaryColor, buttonColor: primaryColor, indicatorColor: Colors.white, splashColor: Colors.white24, splashFactory: InkRipple.splashFactory, accentColor: const Color(0xFF13B9FD), canvasColor: Colors.white, scaffoldBackgroundColor: Colors.white, backgroundColor: Colors.white, errorColor: const Color(0xFFB00020), buttonTheme: const ButtonThemeData( textTheme: ButtonTextTheme.primary, ), textTheme: _buildTextTheme(base.textTheme), primaryTextTheme: _buildTextTheme(base.primaryTextTheme), accentTextTheme: _buildTextTheme(base.accentTextTheme), );&#125;"},{"title":"Flutter setup","date":"2018-10-08T13:20:00.000Z","path":"2018/10/08/2018/Flutter setup/","text":"万事开头难，先把环境搞起来 配置镜像flutter还在墙外，为了我们墙内人们能顺畅使用，官方提供了一个临时镜像： 在命令行只能更新当前会话的PATH变量，写在.bash_profile(bash) .zshrc(zsh) 可以永久修改此变量 12export PUB_HOSTED_URL=https://pub.flutter-io.cnexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn 获取Flutter SDK 去flutter官网下载其最新的安装包，推荐下载Beta的，不过下好了也可以切分支，下载地址 解压文件到开发目录 12cd ~/developmentunzip ~/Downloads/flutter_macos_v0.5.1-beta.zip 配置环境变量 打开或创建HOME/.bash_profile(bash)，加入这行： 12export PATH=[PATH_TO_FLUTTER_GIT_DIRECTORY]/flutter/bin:$PATHeg：export PATH=$PATH:$HOME/github/flutter/bin 关掉或重新载入一下bash环境，实施输入flutter命令，有反应说明环境配置ok 使用zsh的小伙伴配置在.zshrc文件中 iOS setup安装Xcode9.0以上安转iOS模拟器1open -a Simulator 调试运行准备 安装homebrew. 打开终端安装一些Flutter在iOS设备调试的工具 1234brew update$ brew install --HEAD libimobiledevice$ brew install ideviceinstaller ios-deploy cocoapods$ pod setup（有安就跳过） 在终端可以试试：flutter doctor，差不多和下面显示类似 123[✓] Flutter (Channel dev, v0.5.8, on Mac OS X 10.13.6 17G65, locale zh-Hans-CN)[✓] iOS toolchain - develop for iOS devices (Xcode 9.4.1)[✓] Connected devices (2 available) Android setup下载安装 Android Studio，已有的升级到3.1以上设置Android模拟器终端试试：flutter doctor，差不多会显示这么多 12345[✓] Flutter (Channel dev, v0.5.8, on Mac OS X 10.13.6 17G65, locale zh-Hans-CN)[✓] Android toolchain - develop for Android devices (Android SDK 27.0.3)[✓] iOS toolchain - develop for iOS devices (Xcode 9.4.1)[✓] Android Studio (version 3.1)[✓] Connected devices (2 available) 配置IDE可以选择Android Studio或者VS Code，这里以Android Studio说明 安转上面已经完成了，启动它 打开插件选项（Preferences&gt;Plugins） 选择Browse repositories，选择Flutter插件安装 重启Android Studio，生效插件 Demo运行个demo试试效果 启动AS，选择File&gt;New Flutter Project 选择Flutter application作为project类型然后点击Next 输入名称，点击Next 点击finish，等待SDK更新安装并创建项目（根据网络花不定时间，时间太长可以用flutter create 创建） 运行应用程序 略作修改，体验下热更新 参考https://medium.com/@nhancv/why-i-move-to-flutter-34c4005b96ef https://flutter.io/get-started/install/ https://juejin.im/post/5b4bfd8af265da0f7d4eec94 https://yq.aliyun.com/articles/627152?utm_content=m_1000013896"},{"title":"2017","date":"2018-03-25T13:08:00.000Z","path":"2018/03/25/2018/2017/","text":"工作17年奋战在一线，参与并推进了这些事儿的进程： 商家APP惠管家上线运行 小管家，管理惠管家版本，基于vue.js 对接了拉卡拉的惠管家上线 惠收银开发上线，基于mvp，kotlin 小伙伴扩充到6人，技术栈包括android，iOS，RN 生活两人形影不离生活在一起，有欢笑，也会有摩擦，需要的是多一份理解，和让步 4月清明回我老家，去摘了树莓，漫田野酸甜可口的树莓，大家开心的采摘，仿佛回到了童年。 5月最开心的事儿是借自己生日之由勒索女票一个三星s8+手机，手感，屏幕和拍照都堪称完美。 8月开始看车，试了320，女票坐后排说头晕，旁边的梅赛德斯，没敢进去；揣着a3的预算看a4l觉得好大，好气派，里面的多媒体好高级，口水流一地，一见倾心。打算加点预算咬牙上a4l乞丐版。但Led大灯，真皮座椅，自动空调都是我无法割舍的啊。。。好好好，加5万上次低配，套路我是服奥迪！ 十一回女票家，开着小车车带我爸妈去他家，父母正式见了面，住了几天，走完定金流程，多亏她家人情通达，我爸妈应付到位，还是蛮顺利的。 11月公司集体去泰国旅游，这次人多了，但感觉并没有超越上一次，比如吃的，住的，还好大家都安全来回。 12月经常见不到谢老板，后来不好的事发生，作为ceo指导并review过我写的python代码，还有人品的潜移默化，这些都无价。比心，祝好！ 2月看了大将军司马懿，感触良多，1，木秀于林，风必摧之；2，成事者，有勇有谋，善克制 感谢女票小金库出血让我开上奥迪 感谢JGG，谢老板技术上的指导和帮助 感谢移动端小伙伴们的努力，在完成业务之余还可以推进技术栈 感谢家人 展望带好外卖敏捷组 每周至少跑步一次 结婚要花钱，要有存款"},{"title":"开发流程约定","date":"2017-12-19T13:46:00.000Z","path":"2017/12/19/2017/git开发流程/","text":"开发流程约定 我司的开发流程，配合gitlab食用，蛮科学的 基本流程主要分支有两个，master 和 dev，master 一般只能由 dev 往里面合并。dev 接收各种BUG修复和新功能。 所有人 fork 一份 upstream（zaixxx/server），然后在自己的 fork（yourname/server）上开发，开发完毕后通过 Pull Request 向 upstream 的 **dev** 分支提交代码。 禁止直接 clone upstream 作为工作环境。如果需要合作的话，直接把某人的 fork 加为 remote 就可以了，然后在他的分支上 pull 和 push。 好处 在自己的分支上可以随便 push -f ，branch 名字即使简单也不会和别人冲突。 主代码仓库可以实现更好的权限控制。 通过设置，可以强制其他人输入 LGTM 才允许合并，强制 Code Review。 坏处 略显麻烦？ 好习惯所有冲突在自己的 repo 和分支上解决，通过 Pull Request 提交回 upstream 应该是一件轻松愉快的事。 尽可能把改动切成小块，零散地提交回 upstream，可以大大减少冲突和合并所带来的成本。 关于代码合并代码存储冲突时，如不是100%确信的情况下，一定要找另一个代码修改人一起来解冲突或者解完后找那个人来Review（解冲突是很容易导致出问题的点） 默认工作流程(1) 把 zaixxx/ 的页面上，点击 fork （star 旁边的那个按钮，可以一起点一下 star) ，你就有了一份自己的仓库 yourname/ 12345678910111213// 克隆到本地 git clone git@aria2.kezaixxx.com:yourname/&lt;project&gt;.git// 添加远端的 zaixxx 源，git remote add zaixxx git@aria2.kezaixxx.com:zaixxx/&lt;project&gt;.git// 如果本地已经有代码仓库，只需要变更远端源地址即可，将 origin 设置为你自己的源。git remote set-url origin git@aria2.kezaixxx.com:&lt;yourname&gt;/server.git //将 zaixxx 设置为再h源头；git remote add zaixxx git@aria2.kezaixxx.com:zaixxx/server.git// 每次开发前，需要执行 git pull zaixxx dev 将最新的代码同步到本地的 dev 分支。 上面两个网址可以方便的在 Gitlab 网页上复制。这里有不熟悉 git 操作的，遇到了什么问题的，以后加到这个文档里面，方便后人。 (2) 添加功能/修复BUG 首先拉取最新的代码12git checkout devgit pull zaixxx dev 切换到你想修复问题或者添加功能的分支1git checkout -b fix_issue 修改东西到本地1234echo print(&quot;Dolores&quot;) &gt; new_world.py git add new_world.py git diff git commit -m &apos;fixes issue, add a new sample file&apos; 推到你自己的远端1git push origin fix_issue (3) 解决可能有的冲突：务必在这个阶段解决各种可能的冲突，减少pull request merge 到 dev 分支时的成本 123456git checkout dev git pull zaixxx devgit checkout fix_issue git merge dev ** XXXX 解决可能出现的冲突 并 git commit **git push origin fix_issue (4) 提交 Pull Request最后你需要做的，就是打开 https://aria2.kezaixxx.com/yourname/ ，提交一个 Pull Request，指向 zaixxx 的 dev（这个已经被设置成默认分支了，应该不需要多余的设置），并assign给某人帮你review。在创建 PR 前，记得自己 Review 一下所有的改动！ (5) Code review完毕以后，点击Merge Request完成代码提交。提交完毕以后即可随时删掉旧的分支。 Pull Request 指南Git推荐设置 大小写敏感：为了避免类似 SVN 中文件名改了大小写之后版本控制不认的问题，推荐大家设置为大小写敏感： 1git config core.ignorecase false 撰写 Pull Request 一个 PR 只围绕一件事情 如果确有必要将几件事情（例如修改特别小、相互之间有依赖等）一起提交 PR，则需要列明具体每一件事情，确保 PR 说明涵盖了所有修改内容。 大片的代码格式整理要作独立提交，不要和代码修改混在一起，以便 Reviewer 能轻松查看干净的代码修改 diff。 避免超大的 PR 超过 1000 行修改行数的 PR 需要考虑是否能拆分为多个子任务分别提 PR（合理的程序结构设计也应该是解耦的）。 如果 PR 包含的提交数量过多，通常是开发过程掺杂了“尝试—修问题—换个方法再来”这样的重构反复。此种情况最好抛弃这些过程提交，新开分支逐个应用有意义的修改，然后提 PR。 PR 标题——概述此次 Pull Request 的目标 例如：尝试用 XXX 方法实现……、优化……、修复在 XX 状态下对 XX 的异常处理。 PR 说明——面向未来的 Reviewer 记住公司里任何人，任何时候都有可能来阅读这个 Pull Request，所以内容和语气都需要面向未来可能的 Reviewer，不要假定对方已经熟悉这些事情的前因后果。 酌情提供关于这些工作起因的说明，记得包含相关链接。例如跟业务息息相关的尽量提供 Trello、来源链接；处理奇异 Bug 最好能有相关线索、资料的链接。 如果有的话，详述反馈需求 如：@某人过目一下代码/讨论某项技术实现/对设计的意见等等。 明确你何时需要反馈。如果这个 PR 还没有完成（仍有一些代码修改待推送）则需醒目注明，给标题加上[WIP]（施工中）的前缀是个简便快捷的方法。 提供反馈 首先要了解下此 PR 的前情提要。 如果你有强烈的反对意见，多花几分钟审视下自己的意见再做反馈。Think Twice。 对反馈的回复 尽量回复所有评论。尊重评论者对 PR 的关心。 提供澄清。解释对方有疑问的实现方案是如何决策的。 链接到相关的后续提交。（“好建议！a1da2324ca 已搞定 :D”） 如果疑惑和争论持续扩大，尝试面对面做充分沟通，之后把线下沟通的内容汇总回复（便于其他人跟踪进展或未来了解详情）。"},{"title":"Android Hotfix","date":"2017-07-09T11:48:00.000Z","path":"2017/07/09/2017/Hot Fix/","text":"会讲述我们为什么这个时间点需要引入热修复，市面上多种解决方案我们选择哪种，为何？ 引入契机 敏捷开发需要有一种方式能快速修复问题，灰度验证，和上线部署 商家端应用，我们提供定制化的硬件，前期是通过全量强制更新上线新功能和修复问题 拉卡拉Pos，惠管家自动更新不能工作 去拉卡拉自带应用商店里更新流程会特别复杂，无法保证新版本安装率 期望目标 能方便的使用热更新快速修复Bug，上线一些小版本功能 能灰度发布测试布丁，和不同功能，AB Test验证产品 定义热更新和自动更新的适用范围 方案对比 平台 Amigo Robust Sophix Tinker 类替换 yes no yes yes So替换 yes no yes yes 资源替换 yes no yes yes 即时生效 可选 yes 部分 no 性能损耗 无 较小 较小 较小 接入复杂度 简单 一般 简单 复杂 侵入式打包 无侵入 依赖侵入 无侵入 依赖侵入 补丁包大小 大 较小 较小 较小 补丁包管理 amigo平台 自建 阿里云 开源三方 文档资料 一般 少 丰富 丰富 成功率 高 非常高 较高 较高 Amigo和Robust原理类似，都是受Instant Run启发，采用hack ClassLoader的方案，优点是可以即时生效，缺点是兼容性不佳，从完成度上看Amigo优于Robust。 Tinker原理是生成差分Dex，与现在的dex合并，并替换现在的dex。优点是可以做到粒度很小的全面修复，兼容性极好，缺点是合dex耗费的时间会比价长，也会占用额外的rom空间，必须重启应用才能生效。相比Amigo它少了四大组件的修复，但认同Tinker的做法，热修复的作用应该是在修复上面而不是添加新的模块，这有些违背职能单一化，加上社区的接受和认可度，Tinker优胜Amigo。 Sophix是Andfix的商业版，可以看成是Andfix+Tinker，基于native hook的Andfix可以带来快速修复bug，立即生效的好处。无法添加新类和方法的缺点可以通过合并生成新Dex的方式解决，加上接入门槛非常低和可靠的补丁托管平台，结合我们现阶段的需求，最终选择Sophix。 操作手法创建应用 登录移动热修复控制台：https://hotfix.console.aliyun.com/ 在MHub控制台点击右上角创建App，填入App名称、分类和描述 快速接入 添加项目根依赖，找到project的build.gradle文件，添加maven地址： 12345repositories &#123; maven &#123; url &quot;http://maven.aliyun.com/nexus/content/repositories/releases&quot; &#125;&#125; 在app的build.gradle里添加sophix依赖： 1compile &apos;com.aliyun.ams:alicloud-android-hotfix:3.0.5&apos; 权限申明 123456&lt;! -- 网络权限 --&gt;&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;&lt;! -- 外部存储读权限，调试工具加载本地补丁需要 --&gt;&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&gt; 配置AndroidManifest文件 在AndroidManifest.xml中间的application节点下添加如下配置：123456789&lt;meta-dataandroid:name=&quot;com.taobao.android.hotfix.IDSECRET&quot;android:value=&quot;App ID&quot; /&gt;&lt;meta-dataandroid:name=&quot;com.taobao.android.hotfix.APPSECRET&quot;android:value=&quot;App Secret&quot; /&gt;&lt;meta-dataandroid:name=&quot;com.taobao.android.hotfix.RSASECRET&quot;android:value=&quot;RSA密钥&quot; /&gt; 将上述value中的值分别改为通过平台HotFix服务申请得到的App Secret和RSA密钥。 混淆配置 12345678910#基线包使用，生成mapping.txt-printmapping mapping.txt#生成的mapping.txt在app/buidl/outputs/mapping/release路径下，移动到/app路径下#修复后的项目使用，保证混淆结果一致#-applymapping mapping.txt#hotfix-keep class com.taobao.sophix.**&#123;*;&#125;-keep class com.ta.utdid2.device.**&#123;*;&#125;#防止inline-dontoptimize Sophix初始化 initialize的调用应该尽可能的早，必须在Application.attachBaseContext()或者Application.onCreate()的最开始进行SDK初始化操作，否则极有可能导致崩溃。而查询服务器是否有可用补丁的操作可以在后面的任意地方。12345678910111213141516171819202122232425262728SophixManager.getInstance().setContext(this) .setAppVersion(appVersion) .setAesKey(null) //.setAesKey(&quot;0123456789123456&quot;) .setEnableDebug(Util.DEBUG) .setPatchLoadStatusStub((mode, code, info, handlePatchVersion) -&gt; &#123; String msg = &quot;&quot; + &quot;Mode:&quot; + mode + &quot; Code:&quot; + code + &quot; Info:&quot; + info + &quot; HandlePatchVersion:&quot; + handlePatchVersion; UtilLog.d(&quot;Tag&quot;, &quot;----initHotFix msg &quot; + msg); switch (code) &#123; case PatchStatus.CODE_LOAD_SUCCESS: // 补丁加载成功 Log.d(&quot;TAG&quot;,&quot;----patch success!!!&quot;); break; case PatchStatus.CODE_LOAD_RELAUNCH: // 新补丁生效需要重启 reStartApplication(); break; case PatchStatus.CODE_LOAD_FAIL: // 内部引擎异常, 此时清空本地补丁 SophixManager.getInstance().cleanPatches(); break; default: &#125; &#125;).initialize(); 补丁包查询 queryAndLoadNewPatch不可放在attachBaseContext 中，否则无网络权限，建议放在后面任意时刻1SophixManager.getInstance().queryAndLoadNewPatch(); 补丁生成 下载补丁制作工具：https://help.aliyun.com/document_detail/53247.html?spm=5176.doc51416.6.548.gBBrt5填入新旧两个包的地址，点击生成Patch 补丁托管 在阿里云移动热修复里找到对应app，核实补丁的目标版本，上次补丁 注意事项发布前请严格按照：扫码内测 =&gt; 灰度发布 =&gt; 全量发布的流程进行，以保证补丁包能够正常在所有Android版本的机型上生效。为了保险起见，理论上我们提供的设备都需要测一遍是否生效。最好也测下以下具有代表性的Android版本就基本没什么大问题了：4.4、5.1、7.0 热修复，我们用在紧急bug修复和小功能迭代上线，这些改动都不会升版本号自动更新，用来上线有四大组件改动的大功能或模块遇到问题先查看文档：https://help.aliyun.com/knowledge_list/51422.html 参考文档https://github.com/Tencent/tinker/wikihttps://tech.meituan.com/android_robust.htmlhttps://github.com/eleme/Amigo/wikihttp://mp.weixin.qq.com/s/uY5N_PSny7_CHOgUA99UjA?spm=5176.doc51416.2.3.lDNHmL"},{"title":"三星S8","date":"2017-05-31T02:32:00.000Z","path":"2017/05/31/2017/三星S8体验/","text":"上个手机是一加2，用了一年，出去玩，必须带充电宝，不然根本没有安全感。屏幕也恰好摔了一下。所以有机会换S8+。 软件： 自带应用就看设置，s8的设置归类科学，显示清新，顶部有快速搜索也非常实用。 相机，计算器的UI交互也非常简单易用 安全文件夹，其实就是一个安全级别很高的应用分身功能 游戏中心，可以设置这个文件夹里的应用运行时的性能通知免打扰 电话，信息交互自然，本地化也做的很好，能自动标注常见的号码 S助手很好用，在杭州呆的两天里，吃喝玩乐都用它解决了，感觉这个总入口的流量好大 Bixby除了几次误按进去，暂时没发现有啥应用场景 锁屏解锁，动态壁纸，搭配面部解锁，体验细腻迅速，丝滑自然 缺点：指纹解锁非常难用，摆放的位置是脑残。用的时候总是担心会按到镜头，很难下意识解锁，只能翻过来眼睛看着手指才能解锁，如果放在摄像头下面会好用很多，只是视觉上不那么好看了。 硬件： 高通835玩王者农药和崩坏3，没有比这更顺的机子了，机身始终温热 电池3500非常耐用，自带的快充，1个半小时就能充满，机身始终温热 买的s8+，握持感优于7plus，点亮屏幕，就美感来说这两完全不是一个维度的东西 摄像头，后置对焦快准白平衡自然像素高，前置毫无下限的磨皮美颜，讨好机主 前后完全对称的双面玻璃，带来温润如玉的手感，和不着边际的视野 曲面屏在s8上应该是大成，自然不炫技，大弧度的4个R角很有灵性和美感 外放音量一般，质感不错 总结：工作相关，三星历代安卓旗舰都有关注，或欣赏或吐槽。绿的出油，文字锯齿的s1，鹅软石的s3，后来买了s5，彻底路转黑，Rom别家一般500M它得1.5G，是塞了多少垃圾进去，刷机还特别麻烦。刷完安全模式就不工作，软件UI奇丑，交互复杂。GPS定位总是会悄悄起进程，导致一天至少2冲。最后因为屏接触不良，服役1年就被弃。一个月前看到S8的信息，被这块屏折服，决定再试一次三星，大不了退货嘛。但真是出乎意料的好用啊！！！ 适用对象：出于各种原因不喜IOS，但内心追求独特，又不把性价比放第一位朋友"},{"title":"Lodash","date":"2017-04-09T07:06:00.000Z","path":"2017/04/09/2017/lodash/","text":"随着时间的过去，我们写码会积累一些习惯，思想，工具和套路代码，让我们下次在做类似工作时可以事半功倍。lodash就是一个js的工具库，它内部封装了常见的数据处理，如字符，数组，对象，日期。传承于underscore，但性能上却更优异。 模块组成 Array，适用于数组类型，比如填充数据、查找元素、数组分片等操作 Collection，适用于数组和对象类型，部分适用于字符串，比如分组、查找、过滤等操作 Date，当前时间戳 Function，适用于函数类型，比如字节流，延迟，缓存，设置钩子等操作 Lang，类型转化和数值比较 Math，数学运算 Number，随机数和数值区间 Object，对象的创建、扩展、类型转换、检索、集合等操作 Seq，创建链式调用，提高执行性能（惰性计算） String，适用于字符串类型 实例1.N次循环 1234567891011// 1. Basic for loop. for(var i = 0; i &lt; 5; i++) &#123; // ... &#125; // 2. Using Array's join and split methods Array.apply(null, Array(5)).forEach(function()&#123; // ... &#125;); // Lodash _.times(5, function()&#123; // ... &#125;); for 语句是执行循环的不二选择，Array.apply 也可以模拟循环，但在上面代码的使用场景下，_.times() 的解决方式更加简洁和易于理解。 2.深层查找属性值 12345678910111213// Fetch the name of the first pet from each owner var ownerArr = [&#123; \"owner\": \"Colin\", \"pets\": [&#123;\"name\":\"dog1\"&#125;, &#123;\"name\": \"dog2\"&#125;]&#125;, &#123; \"owner\": \"John\", \"pets\": [&#123;\"name\":\"dog3\"&#125;, &#123;\"name\": \"dog4\"&#125;] &#125;]; // Array's map method. ownerArr.map(function(owner)&#123; return owner.pets[0].name; &#125;); // Lodash _.map(ownerArr, 'pets[0].name'); _.map 方法是对原生 map 方法的改进，其中使用 pets[0].name 字符串对嵌套数据取值的方式简化了很多冗余的代码，非常类似使用 jQuery 选择 DOM 节点 ul &gt; li &gt; a，对于前端开发者来说有种久违的亲切感。"},{"title":"我的2016","date":"2017-02-01T22:02:00.000Z","path":"2017/02/02/2017/2016/","text":"作为一个每年都要迁徙回家过年的俗人，现在写16年的总结应该也是说的过去的。 工作16年主要工作还是android方向，还写了点python接口，现学现用了react大礼包。在pad，pos和数据面板做了一点微小的工作。 感谢组织的信任，日常维护着商户管家的相关FAQ。 生活和女朋友吃喝拉撒在一起，感觉被照顾着，很开心😄 4月的某个周末去浙江一个竹林爬山，挺累，但是便宜啊，而且有锻炼到。 5月的海南已然是炎夏了，蜈支洲岛的水特别蓝，玩了5天，特别放松。 6月公司集体去越南旅游，好吃的鸡肉米粉，比海南更好的沙滩，消费也特别低，是个去海边度假的好去处，人民币在那里特别管用。 技能点android技能点广度有所增加 python下半年用的少，和去年这个时候差不多了 前端技能全面有所长进，css3 sass flex，javascript es6，框架react，redux，还补了一遍js红宝书，应该是入门了。 感谢的女朋友这一年的关怀与“嫌弃” 感谢前端大神在js和react上给予帮助和指导 感谢后端大神提供的靠谱api和各种高屋建瓴般建议 感谢今年新招的移动端小伙伴靠谱的配合和多次超出预期的表现，让我知道后生可畏，自己也不能懈怠。 展望2017多看，多想，多写代码 swift 3应该可以喝一壶的 监督女朋友培养正确价值观 多想想健康 多倾听他人 普瑞路326号 34302146"},{"title":"Hello Hexo","date":"2016-12-28T15:30:00.000Z","path":"2016/12/28/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"}]