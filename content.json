[{"title":"Flutter Redux 进阶","date":"2018-12-09T15:08:00.000Z","path":"2018/12/09/2018/Flutter redux 进阶/","text":"目的 认识Flutter Redux局限性 引入Middleware必要性 全方位集成UT Flutter Redux初代实现局限性UT不好覆盖 页面 初代实现一个页面的结构是这样的： 1234567891011121314class XXXScreen extends StatefulWidget &#123; @override _XXXScreenState createState() =&gt; _XXXScreenState();&#125;class _XXXScreenState extends State&lt;XXXScreen&gt; &#123; @override Widget build(BuildContext context) &#123; return StoreConnector&lt;AppState, _XXXViewModel&gt;( converter: (store) =&gt; _XXXViewModel.fromStore(store), builder: (BuildContext context, _XXXViewModel vm) =&gt; Container()); &#125;&#125; 会有两个问题：UI视图和Redux数据通用逻辑耦和在一起，无发通过mock数据来对UI进行UT；大家习惯套路代码，上来就是一个stful，不会想是不是stless更科学点（事实上初代实现80%的Screen是Statefull的，重构后90%都能写成Stateless，提升了页面刷新效率）。 API call 我们的API就是一个静态方法： 12345678910static fetchxxx() &#123; final access = StoreContainer.access; final apiFuture = Services.rest.get('/zpartner_api/$&#123;access.path&#125;/$&#123;access.businessGroupUid&#125;/xxxx/'); Services.asyncRequest( apiFuture, xxxRequestAction(), (json) =&gt; xxxSuccessAction(payload: xxxInfo.fromJson(json)), (errorInfo) =&gt; xxxFailureAction(errorInfo: errorInfo));&#125; 优点是简单，有java味，缺点是：静态方法无法使用mockIto；一个Api call触发，那就发出去了，无法撤销无法重试；自然也无法进行UT覆盖。 不够Functional上面提到的页面和API call都体现了不Functional，还有我们初代Reducer的写法也是大家很熟悉的OO写法123456789101112131415class xxxReducer &#123; xxxState reducer(xxxState state, ActionType action) &#123; switch (action.runtimeType) &#123; case xxxRequestAction: return state.copyWith(isLoading: ); case xxxSuccessAction: return state.copyWith(isLoading: ); case xxxFailureAction: return state.copyWith(isLoading: ); default: return state; &#125; &#125;&#125; 从上到下流水写法，static，switch case这都是我们OO的老朋友。但既然Dart是偏前端特性，Functional才是科学的方向啊。 引入Middleware必要性 业务已经写完，小伙伴边自测边写UT，为了达到50%的coverage可以说是非常蛋疼了。某大佬眉头一皱发现问题并不简单，UT不好写，是不是结构搓？于是召集大家讨论一波，得出这些局限性。改还是不改是个问题，不改开发算是提前完成，反正Rn也没有写UT；改的话，改动量是巨大的。大家都停下手中的工作，思考并深刻讨论这个问题，于是我们从三个方向衡量这个问题： 业务影响离排期提测时间只有1个星期，加入Middleware会有80%的代码需要挪动，改完还要补UT，重新自测。emmm，工作量超大。和产品沟通了下，其实这个业务就是技术重构性质，线上Rn多跑一个礼拜也无碍，测试组也恰好特别忙，delay一周他们觉得ok。倾向改。 技术栈影响从长远看，改动是进步的。对UT友好，更严谨的结构，也更Functional。小伙伴们觉得自己也能驾驭，不过是多写点套路代码～，技术栈倾向改。 伙伴支持度引入Middleware带来的好处能否让小伙伴愿意加班把自己的模块都改写了，还补上UT？实践出真知，所以大家讨论决定，用半天时间理解并改写一个小模块，再投票决定是否改。讨论很激烈，话题一度跑偏。。。 讨论下来，最终决定是改，一星期后大家都说，真香！ 改动点增删 删掉原来Service的static API定义，加入Middleware和Repository。Middleware负责网络请求，数据处理，并根据数据状态进行Action的分发。Repository功能是定义了一个数据来源（可能来源于网络，也可能是数据库），因为引入Dio，所以会很精简，形式上可以看成是一个Endpoint定义。 Middleware 12345678910111213141516171819class XXXMiddlewareFactory extends MiddlewareFactory &#123; XXXMiddlewareFactory(AppRepository repository) : super(repository); @override List&lt;Middleware&lt;AppState&gt;&gt; generate() &#123; return [ TypedMiddleware&lt;AppState, FetchAction&gt;(_fetchXXX), ]; &#125; void _fetchXXX(Store&lt;AppState&gt; store, FetchAction action, NextDispatcher next) &#123; Services.asyncRequest( () =&gt; repository.fetch(), FetchRequestAction(), (json) =&gt; FetchSuccessAction(), (errorInfo) =&gt; FetchFailureAction(errorInfo: errorInfo)); &#125;&#125; Repository 1234Future&lt;Response&gt; fetchXXX(String uid) &#123; return Services.rest.get( '/xxx_api/$&#123;path&#125;/$&#123;groupUid&#125;/manual_activities/$uid/');&#125; 修改 Screen把UI都抽到Presentation里，它依赖一个vm。数据填充并驱动UI变化，这样UI也可以写很全面的UT。Reducer则是利用Flutter_redux库提供的combineReducers方法，将原来一个大的Reducer粒度切到最小。方便写UT和业务增量迭代。 Screen 1234567891011121314151617181920212223242526272829303132333435class XXXPresentation extends StatelessWidget &#123; final XXXViewModel vm; const XXXPresentation(&#123;Key key, this.vm&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return Container(); &#125;&#125;class XXXScreen extends StatelessWidget &#123; static const String routeName = 'xxx_screen'; @override Widget build(BuildContext context) &#123; return StoreConnector&lt;AppState, XXXViewModel&gt;( distinct: true, onInit: (store) &#123; store.dispatch(FetchXXXAction(isRefresh: true)); &#125;, onDispose: (store) =&gt; store.dispatch(XXXResetAction()), converter: XXXViewModel.fromStore, builder: (context, vm) &#123; return XXXPresentation(vm: vm); &#125;, ); &#125;&#125;class XXXViewModel &#123; static XXXViewModel fromStore(Store&lt;AppState&gt; store) &#123; return XXXViewModel(); &#125;&#125; Reducer 12345678910111213141516171819202122232425@immutableclass XXXState &#123; final bool isLoading; XXXState(&#123;this.isLoading, &#125;); XXXState copyWith(&#123;bool isLoading, &#125;) &#123; return XXXState( isLoading: isLoading ?? this.isLoading, ); &#125; XXXState.initialState() : isLoading = false;&#125;final xXXReducer = combineReducers&lt;XXXState&gt;([ TypedReducer&lt;XXXState, Action&gt;(_onRequest),]);XXXState _onRequest(XXXState state, Action action) =&gt; state.copyWith(isLoading: false); UT集成 现在的coverage是48%，核心模块有80%+，有必要的话达到95%以上时完全ok的。原因是解耦以后方方面面都可以UT了 widget(纯) 12// 官方文档写的清楚明白https://flutter.io/docs/testing Utils 被多次使用的才会抽成工具类，纯逻辑也很容易写测试，UT应该先满上。 123456789101112131415group('test string util', () &#123; test('isValidPhone', () &#123; var boolNull = StringUtil.isValidPhone(null); var boolStarts1 = StringUtil.isValidPhone('17012341234'); var boolStarts2 = StringUtil.isValidPhone('27012341234'); var boolLength10 = StringUtil.isValidPhone('1701234123'); var boolLength11 = StringUtil.isValidPhone('17012341234'); expect(boolNull, false); expect(boolStarts1, true); expect(boolStarts2, false); expect(boolLength10, false); expect(boolLength11, true); &#125;);&#125; Presentation 业务的载体。对于比较核心的业务，无论是流程规范定义还是数据边界条件都可以用UT来自动化保障。 1234567891011121314151617181920group('test login presentation', () &#123; Store&lt;AppState&gt; store; setUp(() &#123; store = Store&lt;AppState&gt;(reduxReducer, initialState: initialReduxState(), distinct: true); StoreContainer.setStoreForTest(store); &#125;); testWidgets('test loading', (WidgetTester tester) async &#123; final vm = LoginViewModel(isLoading: true, isSendPinSuccess: false); await TestHelper.pumpWidget(tester, store, LoginPresentation(vm: vm)); expect(find.byType(CupertinoActivityIndicator), findsOneWidget); ... &#125;); testWidgets('test has data',(WidgetTester tester) async &#123; ... &#125;); testWidgets('test has no data',(WidgetTester tester) async &#123; ... &#125;); &#125; Reducer 存放数据，可以用UT来验证特定Action是否改变了特定的数据。 1234567891011121314group('notificationReducer', () &#123; test('FetchMessageUnreadRequestAction', () &#123; store.dispatch(FetchMessageUnreadRequestAction()); expect(store.state.notification.isLoading, true); &#125;); test('FetchMessageUnreadSuccessAction', () &#123; final payload = MessageUnreadInfo.initialState(); store.dispatch(FetchMessageUnreadSuccessAction(payload: payload)); expect(store.state.notification.messageUnreadInfo, payload); expect(store.state.notification.isLoading, false); &#125;); ...&#125; Middleware 叫中间件代表它不是必须，是可以被插拔，可以叠加多个的。每个中间件会有一个明确的任务，我们引入的中间件在这里是处理网络数据，根据情况发对应Action。 123456789101112131415161718192021222324group('Middleware', () &#123; final repo = MockAppRepository(); Store&lt;AppState&gt; store; setUpAll(() async &#123; await mockApiSuc(repo); &#125;); setUp(() &#123; store = Store&lt;AppState&gt;(reduxReducer, initialState: initialReduxState(), middleware: initialMiddleware(repo), distinct: true); StoreContainer.setStoreForTest(store); &#125;); group('NotificationMiddlewareFactory', () &#123; test('FetchMessageUnreadAction', () &#123; store.dispatch(FetchMessageUnreadAction()); verify(repo.fetchMessagesUnread()); &#125;); test('FetchMessageForHomeAction', () &#123; store.dispatch(FetchMessageForHomeAction()); verify(repo.fetchMessagesForHome()); &#125;); ... &#125; 参考flutter_redux_sample flutter_architecture_samples One More Thing TNT，让你的工作效率提高几百倍，老罗认真严肃的说。开个玩笑，这个有待验证。但Live Templates，提升你的编程效率和体验，肯定是真的 使用地址：https://github.com/hui-z/live-templates （完）"},{"title":"Flutter Redux","date":"2018-11-24T14:45:00.000Z","path":"2018/11/24/2018/Flutter redux/","text":"目的 Redux是什么 Redux在Flutter里的作用 Flutter里如何使用Redux 效果Flutter App本质上是一个单页面应用，需要我们自己维护State，Model，Route。随着业务的增加，这些工作会变得很复杂，也不可预测，复现一个bug会很困难，跨组件传递数据也很难。Redux思想继承于Flux，通过合理的约定让业务分层解耦，数据的变动可以预测，可以重现。Redux有三个原则： 1.单一的数据来源（App统一的Store） 2.状态State是只读的（数据不能直接修改，只能用过约定的Action触发，Reduce修改） 3.数据改动须是纯函数（这些纯函数叫Reducer，定义了如何修改Store，由Action触发） 原理Redux（3.0.0）是作者用Dart把JS 的redux库实现了，它定义了Store，Action，Reduce，Middleware以及它们之间的行为关系。 flutter_redux（0.5.2）作为工具类桥接Redux和Flutter，它提供了StoreProvider，StoreBuilder，StoreConnector这些组件，使我们在flutter中使用redux变的很简便。 流程图 ActionAction定义一种行为，可以携带信息，发往Store。换言之Store发生改变须由Action触发。Live Template快捷键ac，创建一套Api Aciton： 1234567891011class xxxRequestAction extends VoidAction &#123;&#125;class xxxSuccessAction extends ActionType &#123; final payload; xxxSuccessAction(&#123;this.payload&#125;) : super(payload: payload);&#125;class xxxFailureAction extends ActionType &#123; final RequestFailureInfo errorInfo; xxxFailureAction(&#123;this.errorInfo&#125;) : super(payload: errorInfo);&#125; APIApp功能最小粒度依赖是API，一般我们前后端会约定一套Rest接口定义。这里APP端是用一个静态方法封装实现的，里面定义了Path，Request，Success，Failure三个Action的响应回调。 12345678910static fetchxxx() &#123; final access = StoreContainer.access; final apiFuture = Services.rest.get('/zpartner_api/$&#123;access.path&#125;/$&#123;access.businessGroupUid&#125;/xxxx/'); Services.asyncRequest( apiFuture, xxxRequestAction(), (json) =&gt; xxxSuccessAction(payload: xxxInfo.fromJson(json)), (errorInfo) =&gt; xxxFailureAction(errorInfo: errorInfo));&#125; Reduce&amp;stateState是Store的一个节点，定义了这个节点的数据申明，Reduce每一次响应Action都会创建一个新的State去替换原来Store里的那个节点State。Reduce和State基本上是一对一的，所以把他们放在一个文件里。Live Template快捷键rd，创建一套Reduce&amp;State： 1234567891011121314151617181920212223242526272829@immutableclass xxxState &#123; final bool isLoading; xxxState(&#123;this.isLoading&#125;); xxxState copyWith(&#123;bool isLoading&#125;) &#123; return xxxState(isLoading: isLoading ?? this.isLoading); &#125; xxxState.initialState() : isLoading = false; &#125;class xxxReducer &#123; xxxState reducer(xxxState state, ActionType action) &#123; switch (action.runtimeType) &#123; case xxxRequestAction: return state.copyWith(isLoading: ); case xxxSuccessAction: return state.copyWith(isLoading: ); case xxxFailureAction: return state.copyWith(isLoading: ); default: return state; &#125; &#125;&#125; Middleware中间件，插在Action触发后还没有到达Reduce之间执行，一般是用来做一些API异步请求并处理。这一步是可选的，当时鉴于Dio网络库对数据有Json处理，flutter_epic表现也还不够稳定。所以我们没用Middleware而是封装了一个工具方法在API services里直接调用处理API并且根据结果分发对应Action。有接入集成测试的需要，需要重点考虑是否引入它。 进阶全局ActionApp里的登出操作是比较特殊的，它可能在不同模块被调起，而且需要做的操作是清空整个Store。我们用了一个GlobalReduce去分发Action 12345678910111213141516AppState reduxReducer(AppState state, action) =&gt; GlobalReducer().reducer(state, action);class GlobalReducer &#123; AppState reducer(AppState state, ActionType action) &#123; switch (action.runtimeType) &#123; case AppRestartAction: hasToken(); return _initialReduxState(); default: return AppState( login: LoginReducer().reducer(state.login, action), ...) &#125; &#125;&#125; APIFuction前面提到我们没有使用Middleware，而是自己封装了一个工具Function，好处是简单易用，缺点是没有明确返回值不好写测试，利弊需要权衡下的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/// common function for network with dio/// Future&lt;Response&gt; apiFuture [Dio.request]/// request action/// success action/// failure actionstatic asyncRequest( Future&lt;Response&gt; apiFuture, ActionType request, ActionType Function(dynamic) success, ActionType Function(RequestFailureInfo) failure,) async &#123; // request StoreContainer.global.dispatch(request); final requestBegin = DateTimeUtil.dateTimeNowMilli(); try &#123; final response = await apiFuture; final requestEnd = DateTimeUtil.dateTimeNowMilli(); final requestSpend = requestEnd - requestBegin; if (requestSpend &lt; requestMinThreshold) &#123; await Future.delayed(Duration( milliseconds: requestMinThreshold - requestSpend)); // 请求返回太快，页面有点卡顿，有点尴尬 todo &#125; // success StoreContainer.global.dispatch(success(response.data)); &#125; on DioError catch (error) &#123; var message = ''; var code = '-1'; var url = ''; if (error.response != null) &#123; var errorData = error.response.data; List messageList = errorData is Map&lt;String, dynamic&gt; ? ((errorData['message']) ?? []) : []; messageList .forEach((item) =&gt; message = message + item.toString() + ' '); code = error.response.statusCode.toString(); url = error.response.request.baseUrl + error.response.request.path; &#125; else &#123; message = error.message; &#125; final model = RequestFailureInfo( errorCode: code, errorMessage: message, dateTime: DateTimeUtil.dateTimeNowIso()); // failure StoreContainer.global.dispatch(failure(model)); &#125;&#125; 局部刷新使用flutter_redux提供的StoreConnector组件时，可以设置distinct为ture，Store变化后是否刷新视图可以完全自己控制。原理是需要重载ViewModel的==运算符和重写hashcode方法。这样在Store变化时，StoreStreamListener通过比对前后两个ViewModel是否相等来触发是否重新builder，而这个是否相等都是我们重写并自己控制的。 123456789101112131415161718192021222324252627class _RestartAppViewModel &#123; Key key; bool isLogin; _RestartAppViewModel(&#123;this.key, this.isLogin&#125;); static _RestartAppViewModel fromStore(Store&lt;AppState&gt; store) =&gt; _RestartAppViewModel( key: store.state.cache.key, isLogin: store.state.cache.isLogin); @override int get hashCode =&gt; key.hashCode ^ isLogin.hashCode; @override bool operator ==(other) =&gt; identical(this, other) || other is _RestartAppViewModel &amp;&amp; key == other.key &amp;&amp; isLogin == other.isLogin;&#125;StoreConnector&lt;AppState, _RestartAppViewModel&gt;( distinct: true, builder: (context, vm) &#123; return App(vm.isLogin, vm.key); &#125;, converter: (store) =&gt; _RestartAppViewModel.fromStore(store)) 参考https://github.com/johnpryan/redux.dart/tree/master/doc （完）"},{"title":"Flutter BottomNavigationBar","date":"2018-11-08T14:28:00.000Z","path":"2018/11/08/2018/Flutter Bottom Navigation Bar/","text":"底部导航是常见的APP布局方式，实际上我自己常用的app都是底部导航的。Android和iOS都有官方组件可供使用。Flutter也有，使用时有踩坑，这里记录一下。 一般用法普通实现: 1234567891011121314BottomNavigationBar botttomNavBar = BottomNavigationBar( items: [ BottomNavigationBarItem(icon: Icon(Icons.code), title: Text(&apos;code&apos;)), BottomNavigationBarItem(icon: Icon(Icons.add), title: Text(&apos;add&apos;)), BottomNavigationBarItem(icon: Icon(Icons.print), title: Text(&apos;print&apos;)) ], currentIndex: _currentIndex, type: BottomNavigationBarType.fixed, onTap: (int index) &#123; setState(() &#123; _currentIndex = index; &#125;); &#125;,); 问：看起来很简单，至于分析这么多吗？ 答：emmmm，这实现优点是设计标准规范，官方组件也简单稳定可靠。但前提是设计师接受这种设定（即使是fixed，选中图标和文字也会有放大缩小动画），至少中国主流的APP，navigation item都是fixed而且没有动画，官方组件并不提供这种选择。 有点问题既然设计师有要求那不能怂，分析是因为内部的_BottomNavigationTile作祟，那自己实现navigationItem控制是否选中，并且不传currentIndex给BottomNavigationBar，应该可以吧 123456789101112131415161718192021222324252627282930313233Widget _buildBottomNavigationBar() &#123; return BottomNavigationBar( type: BottomNavigationBarType.fixed, items: [ _buildItem(icon: Icons.code, tabItem: TabItem.code), _buildItem(icon: Icons.add, tabItem: TabItem.add), _buildItem(icon: Icons.print, tabItem: TabItem.print), ], onTap: _onSelectTab, );&#125;// 用定制化的icon和tabItem构建BottomNavigationBarItemBottomNavigationBarItem _buildItem(&#123;IconData icon, TabItem tabItem&#125;) &#123; String text = tabItemName(tabItem); return BottomNavigationBarItem( icon: Icon( icon, color: _colorTabMatching(item: tabItem), ), title: Text( text, style: TextStyle( color: _colorTabMatching(item: tabItem), ), ), );&#125;// 切换item的颜色，选中用primaryColor，其他都是grey Color _colorTabMatching(&#123;TabItem item&#125;) &#123; return currentItem == item ? Theme.of(context).primaryColor : Colors.grey;&#125; 问：效果如何？ 答：嗯，不错。等等。。。啊，怎么有个大一点。没道理啊，事出蹊跷必有妖，需要从源码中找答案了。下图的home明显比mail大，对吧？ 源码阅读主要代码都在bottom_navigation_bar.dart里，bottom_navigation_bar_item.dart是item的定义 bottom_navigation_bar_item.dart 相当于是一个自定义的Button，用来放在BottomNavigationBar上，它实现了Material(Android)和Cupertino(iOS)两种风格。 bottom_navigation_bar.dart Scaffold是Root Widget- MaterialApp的脚手架。封装了Material Design App会用到的AppBar，Drawer，SnackBar，BottomNavigationBar等。BottomNavigationBarType有fixed 和shifting两种样式，超过\u0010\u0010\u00103个才会有区别，一般为了体验一致，我们会用fixed type。 BottomNavigationBar是一个StatefulWidget，可以按以下步骤分析这种组件：1，先看它持有的状态，2，看下他的生命周期实现，3，再仔细分析它的build方法。 持有状态 123456789List&lt;AnimationController&gt; _controllers = &lt;AnimationController&gt;[];List&lt;CurvedAnimation&gt; _animations;// A queue of color splashes currently being animated.final Queue&lt;_Circle&gt; _circles = Queue&lt;_Circle&gt;();// Last splash circle's color, and the final color of the control after// animation is complete.Color _backgroundColor; 前面三个属性都和动画相关，第四个是设背景。 问：BottomNavigationBar为什么没有变量标记当前哪个item选中？ 答：函数式编程一个原则是要函数尽量纯，currentIndex这个属性依赖外边传入，每次变化重新触发Render。如果自己维护，则还需要提供一个回调方法供外部调用，返回最新的currentIndex值。 生命周期方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 初始化操作，具体实现再resetState里，对上面的这些状态属性初始化操作@overridevoid initState() &#123; super.initState(); _resetState();&#125;// 回收资源操作，一般用到动画都需要的@overridevoid dispose() &#123; for (AnimationController controller in _controllers) controller.dispose(); for (_Circle circle in _circles) circle.dispose(); super.dispose(); &#125;// 当属性变化时Flutter系统回调该方法。当item数量变化时直接重新初始化；当index变化，做相应动画。@overridevoid didUpdateWidget(BottomNavigationBar oldWidget) &#123; super.didUpdateWidget(oldWidget); // No animated segue if the length of the items list changes. if (widget.items.length != oldWidget.items.length) &#123; _resetState(); return; &#125; if (widget.currentIndex != oldWidget.currentIndex) &#123; switch (widget.type) &#123; case BottomNavigationBarType.fixed: break; case BottomNavigationBarType.shifting: _pushCircle(widget.currentIndex); break; &#125; _controllers[oldWidget.currentIndex].reverse(); _controllers[widget.currentIndex].forward(); &#125; if (_backgroundColor != widget.items[widget.currentIndex].backgroundColor) _backgroundColor = widget.items[widget.currentIndex].backgroundColor; &#125;// 下面分析@overrideWidget build(BuildContext context) &#123;&#125; 注意：initState里有个操作比较隐蔽：_controllers[widget.currentIndex].value = 1.0; 分析build方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@override Widget build(BuildContext context) &#123; // debug 检查 assert(debugCheckHasDirectionality(context)); assert(debugCheckHasMaterialLocalizations(context)); // Labels apply up to _bottomMargin padding. Remainder is media padding. final double additionalBottomPadding = math.max(MediaQuery.of(context).padding.bottom - _kBottomMargin, 0.0); // 根据BottomNavigationBarType设背景色，shifting才会有 Color backgroundColor; switch (widget.type) &#123; case BottomNavigationBarType.fixed: break; case BottomNavigationBarType.shifting: backgroundColor = _backgroundColor; break; &#125; return Semantics( // Semantics用来实现无障碍的 container: true, explicitChildNodes: true, child: Stack( children: &lt;Widget&gt;[ Positioned.fill( child: Material( // Casts shadow. elevation: 8.0, color: backgroundColor, ), ), ConstrainedBox( constraints: BoxConstraints(minHeight: kBottomNavigationBarHeight + additionalBottomPadding), child: Stack( children: &lt;Widget&gt;[ Positioned.fill( // 点击时的圆形类波纹动画 child: CustomPaint( painter: _RadialPainter( circles: _circles.toList(), textDirection: Directionality.of(context), ), ), ), Material( // Splashes. type: MaterialType.transparency, child: Padding( padding: EdgeInsets.only(bottom: additionalBottomPadding), child: MediaQuery.removePadding( context: context, removeBottom: true, // tiles就是_BottomNavigationTile，里面放BottomNavigationBarItem child: _createContainer(_createTiles()), )))]))])); &#125;&#125; _BottomNavigationTile看下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 Widget _buildIcon() &#123; ... // 构建Iocn &#125; Widget _buildFixedLabel() &#123; .... // 骚操作，用矩阵来给文字作动画，更平滑 // The font size should grow here when active, but because of the way // font rendering works, it doesn't grow smoothly if we just animate // the font size, so we use a transform instead. child: Transform( transform: Matrix4.diagonal3( Vector3.all( Tween&lt;double&gt;( begin: _kInactiveFontSize / _kActiveFontSize, end: 1.0, ).evaluate(animation), ), ), alignment: Alignment.bottomCenter, child: item.title, ), ), ), ); &#125; Widget _buildShiftingLabel() &#123; return Align(..... // shifting的label是fade动画，只有当前选中的才会显示label child: FadeTransition( alwaysIncludeSemantics: true, opacity: animation, child: DefaultTextStyle.merge( style: const TextStyle( fontSize: _kActiveFontSize, color: Colors.white, ), child: item.title, ), ), ), ); &#125; @override Widget build(BuildContext context) &#123; int size; Widget label; // 生成不同的label switch (type) &#123; case BottomNavigationBarType.fixed: size = 1; label = _buildFixedLabel(); break; case BottomNavigationBarType.shifting: size = (flex * 1000.0).round(); label = _buildShiftingLabel(); break; &#125; return Expanded( .... children: &lt;Widget&gt;[ _buildIcon(), label, ], ), ), Semantics( label: indexLabel,&#125; 改进实现通过分析分析源码，发现原因是bottomNavigationBarState的initState里_controllers[widget.currentIndex].value = 1.0设了currentIndex item动画的初值，currentIndex的默认值是0，所以第一个图标会大一点点。这个问题也有比较鸡贼的手法可以处理（魔改源码什么～），但这样大家都觉得不妥。同事眉头一皱，做了一个大胆的决定，不用系统组件BottomNavigationBar，自己封装一下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// SafeArea来兼容下iPhone X，android和iOS阴影不一样，所以区分下。Widget _buildBottomNavigationBar() &#123; return SafeArea( child: SizedBox( height: 50.0, child: Card( color: Platform.isIOS ? Colors.transparent : Colors.white, elevation: Platform.isIOS ? 0.0 : 8.0, // iphone 无阴影 shape: RoundedRectangleBorder(), margin: EdgeInsets.all(0.0), child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Divider(), Expanded( child: Row( mainAxisAlignment: MainAxisAlignment.center, crossAxisAlignment: CrossAxisAlignment.center, children: &lt;Widget&gt;[ _buildBottomItem( image: HImages.home, text: '首页', index: 0), _buildBottomItem( image: HImages.stats, text: '数据', index: 1), _buildBottomItem( image: HImages.mine, text: '我的', index: 3) ]), ) ]))));&#125;// 封装的BottomItem，选中颜色为primaryColor，未选中grey。点击波纹效果InkResponseWidget _buildBottomItem(&#123;String image, String text, int index&#125;) &#123; Color color = currentIndex == index ? Theme.of(context).primaryColor : Colors.grey; return Expanded( child: InkResponse( child: Column( mainAxisAlignment: MainAxisAlignment.center, crossAxisAlignment: CrossAxisAlignment.center, children: &lt;Widget&gt;[ Image.asset(image, color: color, width: 22.0, height: 22.0), Text(text, style: TextStyle(color: color, fontSize: 10.0)) ]), onTap: () =&gt; setState(() =&gt; currentIndex = index)));&#125; 问：这该是最终版了吧？* 答：Naive，是连iPhone X都考虑了，但细节渐变颜色，platform特性支持还没有。。。说到特性我就佛了，一佛，我就想起西天取经，明年年初，中美合拍的西游记即将正式开机，我继续扮演美猴王孙悟空，我会用美猴王艺术形象努力创造一个正能量的形象，文体两开花，弘扬中华文化，希望大家多多关注。 一些收获 组件动画实现可以参考BottomNavigationBar，规范， 文字动画实现可以用Matrix4和Vector3，比较高级（这个在TabBar用上了）， 考虑给官方提个issue（需求比较区域化）。 本文源码地址：https://github.com/hyjfine/flutter-play （完）"},{"title":"Flutter Theme","date":"2018-10-15T06:51:00.000Z","path":"2018/10/15/2018/Flutter Theme/","text":"主题（Theme）在软件开发里 属于高级追求，Mac OS经过多年演化后终于在macOS Mojave中加入深色主题，可以让你做起事来更专注。 作用 取悦用户，白菜萝卜给用户更多个性化选择 提升效率，比如深色主题让人更专注，演示模式让内容更突出 组成主题（Theme）一般是由color，BG image，fontSize，font等资源组成 Android/iOSandroid应用资源都在资源路径src/res下，style相关改动可以通过activity的setTheme来切换，图片换肤一般会将资源打成一个不带launcher icon的Apk，用Resource实例去加载特定资源；而iOS相应的配置信息都预先写在plist文件里，通过一个ThemeManager实例来控制应用使用哪套资源配置。 FlutterMaterialApp组件接受一个theme参数，通过改变theme的数据，组件会实时重新渲染 Flutter Theme实现Flutter UI也是树形结构。每个节点都是一个widget，根（Root）节点是WidgetsApp，MaterialApp，CupertinoApp之一。Flutter的特色就是对Material design进行了高质量的实现，所以为了更便利的使用这些内置组件，通常是会用MaterialApp widget作为根组件，它也是唯一提供Theme支持的根组件。Theme的类型是ThemeData，它的接受的定义如图所示：实际上我们只会定义一些有关的属性，举个例子Flutter sdk example，gallery。它定义了Dark和Light两套主题： 12345678910111213141516171819202122232425262728293031323334353637383940414243ThemeData _buildDarkTheme() &#123; const Color primaryColor = Color(0xFF0175c2); final ThemeData base = ThemeData.dark(); return base.copyWith( primaryColor: primaryColor, // 应用主颜色 buttonColor: primaryColor, // 按钮颜色 indicatorColor: Colors.white, // 指示器颜色 accentColor: const Color(0xFF13B9FD), // 突出颜色 canvasColor: const Color(0xFF202124), // 画布颜色 scaffoldBackgroundColor: const Color(0xFF202124), // 返回键按钮 backgroundColor: const Color(0xFF202124), // 背景色 errorColor: const Color(0xFFB00020), // 错误色 buttonTheme: const ButtonThemeData( textTheme: ButtonTextTheme.primary, ), // 按钮主题 textTheme: _buildTextTheme(base.textTheme), // 普通文本主题 primaryTextTheme: _buildTextTheme(base.primaryTextTheme), // 主文本主题 accentTextTheme: _buildTextTheme(base.accentTextTheme), // 强调文本主题 );&#125;ThemeData _buildLightTheme() &#123; const Color primaryColor = Color(0xFF0175c2); final ThemeData base = ThemeData.light(); return base.copyWith( primaryColor: primaryColor, buttonColor: primaryColor, indicatorColor: Colors.white, splashColor: Colors.white24, splashFactory: InkRipple.splashFactory, accentColor: const Color(0xFF13B9FD), canvasColor: Colors.white, scaffoldBackgroundColor: Colors.white, backgroundColor: Colors.white, errorColor: const Color(0xFFB00020), buttonTheme: const ButtonThemeData( textTheme: ButtonTextTheme.primary, ), textTheme: _buildTextTheme(base.textTheme), primaryTextTheme: _buildTextTheme(base.primaryTextTheme), accentTextTheme: _buildTextTheme(base.accentTextTheme), );&#125;"},{"title":"Flutter setup","date":"2018-10-08T13:20:00.000Z","path":"2018/10/08/2018/Flutter setup/","text":"万事开头难，先把环境搞起来 配置镜像flutter还在墙外，为了我们墙内人们能顺畅使用，官方提供了一个临时镜像： 在命令行只能更新当前会话的PATH变量，写在.bash_profile(bash) .zshrc(zsh) 可以永久修改此变量 12export PUB_HOSTED_URL=https://pub.flutter-io.cnexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn 获取Flutter SDK 去flutter官网下载其最新的安装包，推荐下载Beta的，不过下好了也可以切分支，下载地址 解压文件到开发目录 12cd ~/developmentunzip ~/Downloads/flutter_macos_v0.5.1-beta.zip 配置环境变量 打开或创建HOME/.bash_profile(bash)，加入这行： 12export PATH=[PATH_TO_FLUTTER_GIT_DIRECTORY]/flutter/bin:$PATHeg：export PATH=$PATH:$HOME/github/flutter/bin 关掉或重新载入一下bash环境，实施输入flutter命令，有反应说明环境配置ok 使用zsh的小伙伴配置在.zshrc文件中 iOS setup安装Xcode9.0以上安转iOS模拟器1open -a Simulator 调试运行准备 安装homebrew. 打开终端安装一些Flutter在iOS设备调试的工具 1234brew update$ brew install --HEAD libimobiledevice$ brew install ideviceinstaller ios-deploy cocoapods$ pod setup（有安就跳过） 在终端可以试试：flutter doctor，差不多和下面显示类似 123[✓] Flutter (Channel dev, v0.5.8, on Mac OS X 10.13.6 17G65, locale zh-Hans-CN)[✓] iOS toolchain - develop for iOS devices (Xcode 9.4.1)[✓] Connected devices (2 available) Android setup下载安装 Android Studio，已有的升级到3.1以上设置Android模拟器终端试试：flutter doctor，差不多会显示这么多 12345[✓] Flutter (Channel dev, v0.5.8, on Mac OS X 10.13.6 17G65, locale zh-Hans-CN)[✓] Android toolchain - develop for Android devices (Android SDK 27.0.3)[✓] iOS toolchain - develop for iOS devices (Xcode 9.4.1)[✓] Android Studio (version 3.1)[✓] Connected devices (2 available) 配置IDE可以选择Android Studio或者VS Code，这里以Android Studio说明 安转上面已经完成了，启动它 打开插件选项（Preferences&gt;Plugins） 选择Browse repositories，选择Flutter插件安装 重启Android Studio，生效插件 Demo运行个demo试试效果 启动AS，选择File&gt;New Flutter Project 选择Flutter application作为project类型然后点击Next 输入名称，点击Next 点击finish，等待SDK更新安装并创建项目（根据网络花不定时间，时间太长可以用flutter create 创建） 运行应用程序 略作修改，体验下热更新 参考https://medium.com/@nhancv/why-i-move-to-flutter-34c4005b96ef https://flutter.io/get-started/install/ https://juejin.im/post/5b4bfd8af265da0f7d4eec94 https://yq.aliyun.com/articles/627152?utm_content=m_1000013896"},{"title":"2017","date":"2018-03-25T13:08:00.000Z","path":"2018/03/25/2018/2017/","text":"工作17年奋战在一线，参与并推进了这些事儿的进程： 商家APP惠管家上线运行 小管家，管理惠管家版本，基于vue.js 对接了拉卡拉的惠管家上线 惠收银开发上线，基于mvp，kotlin 小伙伴扩充到6人，技术栈包括android，iOS，RN 生活两人形影不离生活在一起，有欢笑，也会有摩擦，需要的是多一份理解，和让步 4月清明回我老家，去摘了树莓，漫田野酸甜可口的树莓，大家开心的采摘，仿佛回到了童年。 5月最开心的事儿是借自己生日之由勒索女票一个三星s8+手机，手感，屏幕和拍照都堪称完美。 8月开始看车，试了320，女票坐后排说头晕，旁边的梅赛德斯，没敢进去；揣着a3的预算看a4l觉得好大，好气派，里面的多媒体好高级，口水流一地，一见倾心。打算加点预算咬牙上a4l乞丐版。但Led大灯，真皮座椅，自动空调都是我无法割舍的啊。。。好好好，加5万上次低配，套路我是服奥迪！ 十一回女票家，开着小车车带我爸妈去他家，父母正式见了面，住了几天，走完定金流程，多亏她家人情通达，我爸妈应付到位，还是蛮顺利的。 11月公司集体去泰国旅游，这次人多了，但感觉并没有超越上一次，比如吃的，住的，还好大家都安全来回。 12月经常见不到谢老板，后来不好的事发生，作为ceo指导并review过我写的python代码，还有人品的潜移默化，这些都无价。比心，祝好！ 2月看了大将军司马懿，感触良多，1，木秀于林，风必摧之；2，成事者，有勇有谋，善克制 感谢女票小金库出血让我开上奥迪 感谢JGG，谢老板技术上的指导和帮助 感谢移动端小伙伴们的努力，在完成业务之余还可以推进技术栈 感谢家人 展望带好外卖敏捷组 每周至少跑步一次 结婚要花钱，要有存款"},{"title":"开发流程约定","date":"2017-12-19T13:46:00.000Z","path":"2017/12/19/2017/git开发流程/","text":"开发流程约定 我司的开发流程，配合gitlab食用，蛮科学的 基本流程主要分支有两个，master 和 dev，master 一般只能由 dev 往里面合并。dev 接收各种BUG修复和新功能。 所有人 fork 一份 upstream（zaixxx/server），然后在自己的 fork（yourname/server）上开发，开发完毕后通过 Pull Request 向 upstream 的 **dev** 分支提交代码。 禁止直接 clone upstream 作为工作环境。如果需要合作的话，直接把某人的 fork 加为 remote 就可以了，然后在他的分支上 pull 和 push。 好处 在自己的分支上可以随便 push -f ，branch 名字即使简单也不会和别人冲突。 主代码仓库可以实现更好的权限控制。 通过设置，可以强制其他人输入 LGTM 才允许合并，强制 Code Review。 坏处 略显麻烦？ 好习惯所有冲突在自己的 repo 和分支上解决，通过 Pull Request 提交回 upstream 应该是一件轻松愉快的事。 尽可能把改动切成小块，零散地提交回 upstream，可以大大减少冲突和合并所带来的成本。 关于代码合并代码存储冲突时，如不是100%确信的情况下，一定要找另一个代码修改人一起来解冲突或者解完后找那个人来Review（解冲突是很容易导致出问题的点） 默认工作流程(1) 把 zaixxx/ 的页面上，点击 fork （star 旁边的那个按钮，可以一起点一下 star) ，你就有了一份自己的仓库 yourname/ 12345678910111213// 克隆到本地 git clone git@aria2.kezaixxx.com:yourname/&lt;project&gt;.git// 添加远端的 zaixxx 源，git remote add zaixxx git@aria2.kezaixxx.com:zaixxx/&lt;project&gt;.git// 如果本地已经有代码仓库，只需要变更远端源地址即可，将 origin 设置为你自己的源。git remote set-url origin git@aria2.kezaixxx.com:&lt;yourname&gt;/server.git //将 zaixxx 设置为再h源头；git remote add zaixxx git@aria2.kezaixxx.com:zaixxx/server.git// 每次开发前，需要执行 git pull zaixxx dev 将最新的代码同步到本地的 dev 分支。 上面两个网址可以方便的在 Gitlab 网页上复制。这里有不熟悉 git 操作的，遇到了什么问题的，以后加到这个文档里面，方便后人。 (2) 添加功能/修复BUG 首先拉取最新的代码12git checkout devgit pull zaixxx dev 切换到你想修复问题或者添加功能的分支1git checkout -b fix_issue 修改东西到本地1234echo print(&quot;Dolores&quot;) &gt; new_world.py git add new_world.py git diff git commit -m &apos;fixes issue, add a new sample file&apos; 推到你自己的远端1git push origin fix_issue (3) 解决可能有的冲突：务必在这个阶段解决各种可能的冲突，减少pull request merge 到 dev 分支时的成本 123456git checkout dev git pull zaixxx devgit checkout fix_issue git merge dev ** XXXX 解决可能出现的冲突 并 git commit **git push origin fix_issue (4) 提交 Pull Request最后你需要做的，就是打开 https://aria2.kezaixxx.com/yourname/ ，提交一个 Pull Request，指向 zaixxx 的 dev（这个已经被设置成默认分支了，应该不需要多余的设置），并assign给某人帮你review。在创建 PR 前，记得自己 Review 一下所有的改动！ (5) Code review完毕以后，点击Merge Request完成代码提交。提交完毕以后即可随时删掉旧的分支。 Pull Request 指南Git推荐设置 大小写敏感：为了避免类似 SVN 中文件名改了大小写之后版本控制不认的问题，推荐大家设置为大小写敏感： 1git config core.ignorecase false 撰写 Pull Request 一个 PR 只围绕一件事情 如果确有必要将几件事情（例如修改特别小、相互之间有依赖等）一起提交 PR，则需要列明具体每一件事情，确保 PR 说明涵盖了所有修改内容。 大片的代码格式整理要作独立提交，不要和代码修改混在一起，以便 Reviewer 能轻松查看干净的代码修改 diff。 避免超大的 PR 超过 1000 行修改行数的 PR 需要考虑是否能拆分为多个子任务分别提 PR（合理的程序结构设计也应该是解耦的）。 如果 PR 包含的提交数量过多，通常是开发过程掺杂了“尝试—修问题—换个方法再来”这样的重构反复。此种情况最好抛弃这些过程提交，新开分支逐个应用有意义的修改，然后提 PR。 PR 标题——概述此次 Pull Request 的目标 例如：尝试用 XXX 方法实现……、优化……、修复在 XX 状态下对 XX 的异常处理。 PR 说明——面向未来的 Reviewer 记住公司里任何人，任何时候都有可能来阅读这个 Pull Request，所以内容和语气都需要面向未来可能的 Reviewer，不要假定对方已经熟悉这些事情的前因后果。 酌情提供关于这些工作起因的说明，记得包含相关链接。例如跟业务息息相关的尽量提供 Trello、来源链接；处理奇异 Bug 最好能有相关线索、资料的链接。 如果有的话，详述反馈需求 如：@某人过目一下代码/讨论某项技术实现/对设计的意见等等。 明确你何时需要反馈。如果这个 PR 还没有完成（仍有一些代码修改待推送）则需醒目注明，给标题加上[WIP]（施工中）的前缀是个简便快捷的方法。 提供反馈 首先要了解下此 PR 的前情提要。 如果你有强烈的反对意见，多花几分钟审视下自己的意见再做反馈。Think Twice。 对反馈的回复 尽量回复所有评论。尊重评论者对 PR 的关心。 提供澄清。解释对方有疑问的实现方案是如何决策的。 链接到相关的后续提交。（“好建议！a1da2324ca 已搞定 :D”） 如果疑惑和争论持续扩大，尝试面对面做充分沟通，之后把线下沟通的内容汇总回复（便于其他人跟踪进展或未来了解详情）。"},{"title":"Android Hotfix","date":"2017-07-09T11:48:00.000Z","path":"2017/07/09/2017/Hot Fix/","text":"会讲述我们为什么这个时间点需要引入热修复，市面上多种解决方案我们选择哪种，为何？ 引入契机 敏捷开发需要有一种方式能快速修复问题，灰度验证，和上线部署 商家端应用，我们提供定制化的硬件，前期是通过全量强制更新上线新功能和修复问题 拉卡拉Pos，惠管家自动更新不能工作 去拉卡拉自带应用商店里更新流程会特别复杂，无法保证新版本安装率 期望目标 能方便的使用热更新快速修复Bug，上线一些小版本功能 能灰度发布测试布丁，和不同功能，AB Test验证产品 定义热更新和自动更新的适用范围 方案对比 平台 Amigo Robust Sophix Tinker 类替换 yes no yes yes So替换 yes no yes yes 资源替换 yes no yes yes 即时生效 可选 yes 部分 no 性能损耗 无 较小 较小 较小 接入复杂度 简单 一般 简单 复杂 侵入式打包 无侵入 依赖侵入 无侵入 依赖侵入 补丁包大小 大 较小 较小 较小 补丁包管理 amigo平台 自建 阿里云 开源三方 文档资料 一般 少 丰富 丰富 成功率 高 非常高 较高 较高 Amigo和Robust原理类似，都是受Instant Run启发，采用hack ClassLoader的方案，优点是可以即时生效，缺点是兼容性不佳，从完成度上看Amigo优于Robust。 Tinker原理是生成差分Dex，与现在的dex合并，并替换现在的dex。优点是可以做到粒度很小的全面修复，兼容性极好，缺点是合dex耗费的时间会比价长，也会占用额外的rom空间，必须重启应用才能生效。相比Amigo它少了四大组件的修复，但认同Tinker的做法，热修复的作用应该是在修复上面而不是添加新的模块，这有些违背职能单一化，加上社区的接受和认可度，Tinker优胜Amigo。 Sophix是Andfix的商业版，可以看成是Andfix+Tinker，基于native hook的Andfix可以带来快速修复bug，立即生效的好处。无法添加新类和方法的缺点可以通过合并生成新Dex的方式解决，加上接入门槛非常低和可靠的补丁托管平台，结合我们现阶段的需求，最终选择Sophix。 操作手法创建应用 登录移动热修复控制台：https://hotfix.console.aliyun.com/ 在MHub控制台点击右上角创建App，填入App名称、分类和描述 快速接入 添加项目根依赖，找到project的build.gradle文件，添加maven地址： 12345repositories &#123; maven &#123; url &quot;http://maven.aliyun.com/nexus/content/repositories/releases&quot; &#125;&#125; 在app的build.gradle里添加sophix依赖： 1compile &apos;com.aliyun.ams:alicloud-android-hotfix:3.0.5&apos; 权限申明 123456&lt;! -- 网络权限 --&gt;&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;&lt;! -- 外部存储读权限，调试工具加载本地补丁需要 --&gt;&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&gt; 配置AndroidManifest文件 在AndroidManifest.xml中间的application节点下添加如下配置：123456789&lt;meta-dataandroid:name=&quot;com.taobao.android.hotfix.IDSECRET&quot;android:value=&quot;App ID&quot; /&gt;&lt;meta-dataandroid:name=&quot;com.taobao.android.hotfix.APPSECRET&quot;android:value=&quot;App Secret&quot; /&gt;&lt;meta-dataandroid:name=&quot;com.taobao.android.hotfix.RSASECRET&quot;android:value=&quot;RSA密钥&quot; /&gt; 将上述value中的值分别改为通过平台HotFix服务申请得到的App Secret和RSA密钥。 混淆配置 12345678910#基线包使用，生成mapping.txt-printmapping mapping.txt#生成的mapping.txt在app/buidl/outputs/mapping/release路径下，移动到/app路径下#修复后的项目使用，保证混淆结果一致#-applymapping mapping.txt#hotfix-keep class com.taobao.sophix.**&#123;*;&#125;-keep class com.ta.utdid2.device.**&#123;*;&#125;#防止inline-dontoptimize Sophix初始化 initialize的调用应该尽可能的早，必须在Application.attachBaseContext()或者Application.onCreate()的最开始进行SDK初始化操作，否则极有可能导致崩溃。而查询服务器是否有可用补丁的操作可以在后面的任意地方。12345678910111213141516171819202122232425262728SophixManager.getInstance().setContext(this) .setAppVersion(appVersion) .setAesKey(null) //.setAesKey(&quot;0123456789123456&quot;) .setEnableDebug(Util.DEBUG) .setPatchLoadStatusStub((mode, code, info, handlePatchVersion) -&gt; &#123; String msg = &quot;&quot; + &quot;Mode:&quot; + mode + &quot; Code:&quot; + code + &quot; Info:&quot; + info + &quot; HandlePatchVersion:&quot; + handlePatchVersion; UtilLog.d(&quot;Tag&quot;, &quot;----initHotFix msg &quot; + msg); switch (code) &#123; case PatchStatus.CODE_LOAD_SUCCESS: // 补丁加载成功 Log.d(&quot;TAG&quot;,&quot;----patch success!!!&quot;); break; case PatchStatus.CODE_LOAD_RELAUNCH: // 新补丁生效需要重启 reStartApplication(); break; case PatchStatus.CODE_LOAD_FAIL: // 内部引擎异常, 此时清空本地补丁 SophixManager.getInstance().cleanPatches(); break; default: &#125; &#125;).initialize(); 补丁包查询 queryAndLoadNewPatch不可放在attachBaseContext 中，否则无网络权限，建议放在后面任意时刻1SophixManager.getInstance().queryAndLoadNewPatch(); 补丁生成 下载补丁制作工具：https://help.aliyun.com/document_detail/53247.html?spm=5176.doc51416.6.548.gBBrt5填入新旧两个包的地址，点击生成Patch 补丁托管 在阿里云移动热修复里找到对应app，核实补丁的目标版本，上次补丁 注意事项发布前请严格按照：扫码内测 =&gt; 灰度发布 =&gt; 全量发布的流程进行，以保证补丁包能够正常在所有Android版本的机型上生效。为了保险起见，理论上我们提供的设备都需要测一遍是否生效。最好也测下以下具有代表性的Android版本就基本没什么大问题了：4.4、5.1、7.0 热修复，我们用在紧急bug修复和小功能迭代上线，这些改动都不会升版本号自动更新，用来上线有四大组件改动的大功能或模块遇到问题先查看文档：https://help.aliyun.com/knowledge_list/51422.html 参考文档https://github.com/Tencent/tinker/wikihttps://tech.meituan.com/android_robust.htmlhttps://github.com/eleme/Amigo/wikihttp://mp.weixin.qq.com/s/uY5N_PSny7_CHOgUA99UjA?spm=5176.doc51416.2.3.lDNHmL"},{"title":"三星S8","date":"2017-05-31T02:32:00.000Z","path":"2017/05/31/2017/三星S8体验/","text":"上个手机是一加2，用了一年，出去玩，必须带充电宝，不然根本没有安全感。屏幕也恰好摔了一下。所以有机会换S8+。 软件： 自带应用就看设置，s8的设置归类科学，显示清新，顶部有快速搜索也非常实用。 相机，计算器的UI交互也非常简单易用 安全文件夹，其实就是一个安全级别很高的应用分身功能 游戏中心，可以设置这个文件夹里的应用运行时的性能通知免打扰 电话，信息交互自然，本地化也做的很好，能自动标注常见的号码 S助手很好用，在杭州呆的两天里，吃喝玩乐都用它解决了，感觉这个总入口的流量好大 Bixby除了几次误按进去，暂时没发现有啥应用场景 锁屏解锁，动态壁纸，搭配面部解锁，体验细腻迅速，丝滑自然 缺点：指纹解锁非常难用，摆放的位置是脑残。用的时候总是担心会按到镜头，很难下意识解锁，只能翻过来眼睛看着手指才能解锁，如果放在摄像头下面会好用很多，只是视觉上不那么好看了。 硬件： 高通835玩王者农药和崩坏3，没有比这更顺的机子了，机身始终温热 电池3500非常耐用，自带的快充，1个半小时就能充满，机身始终温热 买的s8+，握持感优于7plus，点亮屏幕，就美感来说这两完全不是一个维度的东西 摄像头，后置对焦快准白平衡自然像素高，前置毫无下限的磨皮美颜，讨好机主 前后完全对称的双面玻璃，带来温润如玉的手感，和不着边际的视野 曲面屏在s8上应该是大成，自然不炫技，大弧度的4个R角很有灵性和美感 外放音量一般，质感不错 总结：工作相关，三星历代安卓旗舰都有关注，或欣赏或吐槽。绿的出油，文字锯齿的s1，鹅软石的s3，后来买了s5，彻底路转黑，Rom别家一般500M它得1.5G，是塞了多少垃圾进去，刷机还特别麻烦。刷完安全模式就不工作，软件UI奇丑，交互复杂。GPS定位总是会悄悄起进程，导致一天至少2冲。最后因为屏接触不良，服役1年就被弃。一个月前看到S8的信息，被这块屏折服，决定再试一次三星，大不了退货嘛。但真是出乎意料的好用啊！！！ 适用对象：出于各种原因不喜IOS，但内心追求独特，又不把性价比放第一位朋友"},{"title":"Lodash","date":"2017-04-09T07:06:00.000Z","path":"2017/04/09/2017/lodash/","text":"随着时间的过去，我们写码会积累一些习惯，思想，工具和套路代码，让我们下次在做类似工作时可以事半功倍。lodash就是一个js的工具库，它内部封装了常见的数据处理，如字符，数组，对象，日期。传承于underscore，但性能上却更优异。 模块组成 Array，适用于数组类型，比如填充数据、查找元素、数组分片等操作 Collection，适用于数组和对象类型，部分适用于字符串，比如分组、查找、过滤等操作 Date，当前时间戳 Function，适用于函数类型，比如字节流，延迟，缓存，设置钩子等操作 Lang，类型转化和数值比较 Math，数学运算 Number，随机数和数值区间 Object，对象的创建、扩展、类型转换、检索、集合等操作 Seq，创建链式调用，提高执行性能（惰性计算） String，适用于字符串类型 实例1.N次循环 1234567891011// 1. Basic for loop. for(var i = 0; i &lt; 5; i++) &#123; // ... &#125; // 2. Using Array's join and split methods Array.apply(null, Array(5)).forEach(function()&#123; // ... &#125;); // Lodash _.times(5, function()&#123; // ... &#125;); for 语句是执行循环的不二选择，Array.apply 也可以模拟循环，但在上面代码的使用场景下，_.times() 的解决方式更加简洁和易于理解。 2.深层查找属性值 12345678910111213// Fetch the name of the first pet from each owner var ownerArr = [&#123; \"owner\": \"Colin\", \"pets\": [&#123;\"name\":\"dog1\"&#125;, &#123;\"name\": \"dog2\"&#125;]&#125;, &#123; \"owner\": \"John\", \"pets\": [&#123;\"name\":\"dog3\"&#125;, &#123;\"name\": \"dog4\"&#125;] &#125;]; // Array's map method. ownerArr.map(function(owner)&#123; return owner.pets[0].name; &#125;); // Lodash _.map(ownerArr, 'pets[0].name'); _.map 方法是对原生 map 方法的改进，其中使用 pets[0].name 字符串对嵌套数据取值的方式简化了很多冗余的代码，非常类似使用 jQuery 选择 DOM 节点 ul &gt; li &gt; a，对于前端开发者来说有种久违的亲切感。"},{"title":"我的2016","date":"2017-02-01T22:02:00.000Z","path":"2017/02/02/2017/2016/","text":"作为一个每年都要迁徙回家过年的俗人，现在写16年的总结应该也是说的过去的。 工作16年主要工作还是android方向，还写了点python接口，现学现用了react大礼包。在pad，pos和数据面板做了一点微小的工作。 感谢组织的信任，日常维护着商户管家的相关FAQ。 生活和女朋友吃喝拉撒在一起，感觉被照顾着，很开心😄 4月的某个周末去浙江一个竹林爬山，挺累，但是便宜啊，而且有锻炼到。 5月的海南已然是炎夏了，蜈支洲岛的水特别蓝，玩了5天，特别放松。 6月公司集体去越南旅游，好吃的鸡肉米粉，比海南更好的沙滩，消费也特别低，是个去海边度假的好去处，人民币在那里特别管用。 技能点android技能点广度有所增加 python下半年用的少，和去年这个时候差不多了 前端技能全面有所长进，css3 sass flex，javascript es6，框架react，redux，还补了一遍js红宝书，应该是入门了。 感谢的女朋友这一年的关怀与“嫌弃” 感谢前端大神在js和react上给予帮助和指导 感谢后端大神提供的靠谱api和各种高屋建瓴般建议 感谢今年新招的移动端小伙伴靠谱的配合和多次超出预期的表现，让我知道后生可畏，自己也不能懈怠。 展望2017多看，多想，多写代码 swift 3应该可以喝一壶的 监督女朋友培养正确价值观 多想想健康 多倾听他人 普瑞路326号 34302146"},{"title":"Hello Hexo","date":"2016-12-28T15:30:00.000Z","path":"2016/12/28/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"}]